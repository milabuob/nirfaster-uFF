

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>nirfasteruff.nirfasteruff &mdash; NIRFASTerUFF 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            NIRFASTerUFF
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/nirfasteruff.html">nirfasteruff</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">NIRFASTerUFF</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">nirfasteruff.nirfasteruff</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for nirfasteruff.nirfasteruff</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.io</span> <span class="k">as</span> <span class="nn">sio</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="kn">import</span> <span class="nn">platform</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">spatial</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">psutil</span>
<span class="kn">import</span> <span class="nn">subprocess</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">nirfasteruff_cpu</span>

<span class="k">if</span> <span class="n">nirfasteruff_cpu</span><span class="o">.</span><span class="n">isCUDA</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">nirfasteruff_cuda</span>

<div class="viewcode-block" id="utils">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.utils.html#nirfasteruff.nirfasteruff.utils">[docs]</a>
<span class="k">class</span> <span class="nc">utils</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Dummy class holding some helper functions and helper classes  </span>
<span class="sd">    Dummy class used so the function hierarchy can be compatible with the full version</span>
<span class="sd">    &#39;&#39;&#39;</span>
<div class="viewcode-block" id="utils.isCUDA">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.utils.html#nirfasteruff.nirfasteruff.utils.isCUDA">[docs]</a>
    <span class="k">def</span> <span class="nf">isCUDA</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if system has a CUDA device with compute capability &gt;=5.2</span>
<span class="sd">        </span>
<span class="sd">        On a Mac machine, it automatically returns False without checking</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if a CUDA device with compute capability &gt;=5.2 exists, False if not.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nirfasteruff_cpu</span><span class="o">.</span><span class="n">isCUDA</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="utils.get_solver">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.utils.html#nirfasteruff.nirfasteruff.utils.get_solver">[docs]</a>
    <span class="k">def</span> <span class="nf">get_solver</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the default solver.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            If isCUDA is true, returns &#39;GPU&#39;, otherwise &#39;CPU&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">isCUDA</span><span class="p">():</span>
            <span class="n">solver</span> <span class="o">=</span> <span class="s1">&#39;GPU&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">solver</span> <span class="o">=</span> <span class="s1">&#39;CPU&#39;</span>     
        <span class="k">return</span> <span class="n">solver</span>            </div>

    
<div class="viewcode-block" id="utils.pointLocation">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.utils.html#nirfasteruff.nirfasteruff.utils.pointLocation">[docs]</a>
    <span class="k">def</span> <span class="nf">pointLocation</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">pointlist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to Matlab&#39;s pointLocation function, queries which elements in mesh the points belong to, and also calculate the barycentric coordinates.</span>
<span class="sd">        </span>
<span class="sd">        This is a wrapper of the C++ function pointLocation, which implememnts an AABB tree based on Darren Engwirda&#39;s findtria package</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mesh : NIRFASTer mesh</span>
<span class="sd">            Can be 2D or 3D.</span>
<span class="sd">        pointlist : NumPy array</span>
<span class="sd">            A list of points to query. Shape (N, dim), where N is number of points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ind : double NumPy array</span>
<span class="sd">            i-th queried point is in element `ind[i`] of mesh (zero-based). If not in mesh, `ind[i]=-1`. Size: (N,).</span>
<span class="sd">        int_func : double NumPy array</span>
<span class="sd">            i-th row is the barycentric coordinates of i-th queried point. If not in mesh, corresponding row is all zero. Size: (N, dim+1).</span>
<span class="sd">            </span>
<span class="sd">        References</span>
<span class="sd">        -------</span>
<span class="sd">        https://github.com/dengwirda/find-tria</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ind</span><span class="p">,</span> <span class="n">int_func</span> <span class="o">=</span> <span class="n">nirfasteruff_cpu</span><span class="o">.</span><span class="n">pointLocation</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">pointlist</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ind</span><span class="p">,</span> <span class="n">int_func</span></div>

    
<div class="viewcode-block" id="utils.check_element_orientation_2d">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.utils.html#nirfasteruff.nirfasteruff.utils.check_element_orientation_2d">[docs]</a>
    <span class="k">def</span> <span class="nf">check_element_orientation_2d</span><span class="p">(</span><span class="n">ele</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make sure the 2D triangular elements are oriented counter clock wise.</span>
<span class="sd">        </span>
<span class="sd">        This is a direct translation from the Matlab version.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ele : NumPy array</span>
<span class="sd">            Elements in a 2D mesh. One-based. Size: (NNodes, 3).</span>
<span class="sd">        nodes : NumPy array</span>
<span class="sd">            Node locations in a 2D mesh. Size: (NNodes, 2).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If ele does not have three rows, i.e. not a 2D triangular mesh.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ele : NumPy array</span>
<span class="sd">            Re-oriented element list.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;check_element_orientation_2d expects a 2D triangular mesh!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">nodes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">ele</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),:]</span> <span class="o">-</span> <span class="n">nodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">ele</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),:]</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">ele</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),:]</span> <span class="o">-</span> <span class="n">nodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">ele</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),:]</span>
        
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="n">ele</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">ele</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])]</span>
        <span class="k">return</span> <span class="n">ele</span></div>

    
<div class="viewcode-block" id="utils.pointLineDistance">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.utils.html#nirfasteruff.nirfasteruff.utils.pointLineDistance">[docs]</a>
    <span class="k">def</span> <span class="nf">pointLineDistance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the distance between a point and a line (defined by two points), and find the projection point</span>
<span class="sd">        </span>
<span class="sd">        This is a direct translation  from the Matlab version</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A : NumPy array</span>
<span class="sd">            first point on the line. Size (2,) or (3,)</span>
<span class="sd">        B : NumPy array</span>
<span class="sd">            second point on the line. Size (2,) or (3,)</span>
<span class="sd">        p : NumPy array</span>
<span class="sd">            point of query. Size (2,) or (3,)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dist : double</span>
<span class="sd">            point-line distance.</span>
<span class="sd">        point : NumPy array</span>
<span class="sd">            projection point on the line.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">-</span><span class="n">A</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="o">-</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">-</span><span class="n">A</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">t</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="n">point</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="p">(</span><span class="n">B</span><span class="o">-</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">t</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">point</span><span class="p">)</span>     
        <span class="k">return</span> <span class="n">dist</span><span class="p">,</span> <span class="n">point</span></div>

    
<div class="viewcode-block" id="utils.pointTriangleDistance">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.utils.html#nirfasteruff.nirfasteruff.utils.pointTriangleDistance">[docs]</a>
    <span class="k">def</span> <span class="nf">pointTriangleDistance</span><span class="p">(</span><span class="n">TRI</span><span class="p">,</span> <span class="n">P</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the distance between a point and a triangle (defined by three points), and find the projection point</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        TRI : Numpy array</span>
<span class="sd">            The three points (per row) defining the triangle. Size: (3,3)</span>
<span class="sd">        P : Numpy array</span>
<span class="sd">            point of query. Size (3,).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dist : double</span>
<span class="sd">            point-triangle distance.</span>
<span class="sd">        PP0 : NumPy array</span>
<span class="sd">            projection point on the triangular face.</span>
<span class="sd">            </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is modified from Joshua Shaffer&#39;s code, available at: https://gist.github.com/joshuashaffer/99d58e4ccbd37ca5d96e</span>
<span class="sd">        </span>
<span class="sd">        which is based on Gwendolyn Fischer&#39;s Matlab code: https://uk.mathworks.com/matlabcentral/fileexchange/22857-distance-between-a-point-and-a-triangle-in-3d</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">B</span> <span class="o">=</span> <span class="n">TRI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">E0</span> <span class="o">=</span> <span class="n">TRI</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">B</span>
        <span class="c1"># E0 = E0/sqrt(sum(E0.^2)); %normalize vector</span>
        <span class="n">E1</span> <span class="o">=</span> <span class="n">TRI</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">B</span>
        <span class="c1"># E1 = E1/sqrt(sum(E1.^2)); %normalize vector</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">B</span> <span class="o">-</span> <span class="n">P</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">E0</span><span class="p">,</span> <span class="n">E0</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">E0</span><span class="p">,</span> <span class="n">E1</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">E1</span><span class="p">,</span> <span class="n">E1</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">E0</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">E1</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
    
        <span class="c1">#print &quot;{0} {1} {2} &quot;.format(B,E1,E0)</span>
        <span class="n">det</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">e</span> <span class="o">-</span> <span class="n">c</span> <span class="o">*</span> <span class="n">d</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">d</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">e</span>
    
        <span class="c1"># Terible tree of conditionals to determine in which region of the diagram</span>
        <span class="c1"># shown above the projection of the point into the triangle-plane lies.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">t</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">det</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="c1"># region4</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="mf">0.0</span>
                        <span class="k">if</span> <span class="o">-</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="p">:</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="mf">1.0</span>
                            <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="n">f</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="o">-</span><span class="n">d</span> <span class="o">/</span> <span class="n">a</span>
                            <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">f</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="mf">0.0</span>
                        <span class="k">if</span> <span class="n">e</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
                            <span class="n">t</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">f</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="o">-</span><span class="n">e</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="p">:</span>
                                <span class="n">t</span> <span class="o">=</span> <span class="mf">1.0</span>
                                <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span> <span class="o">+</span> <span class="n">f</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">t</span> <span class="o">=</span> <span class="o">-</span><span class="n">e</span> <span class="o">/</span> <span class="n">c</span>
                                <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">e</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">f</span>
    
                                <span class="c1"># of region 4</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># region 3</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">f</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="o">-</span><span class="n">e</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="p">:</span>
                            <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span> <span class="o">+</span> <span class="n">f</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">t</span> <span class="o">=</span> <span class="o">-</span><span class="n">e</span> <span class="o">/</span> <span class="n">c</span>
                            <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">e</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">f</span>
                            <span class="c1"># of region 3</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># region 5</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">f</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="o">-</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="p">:</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="n">f</span><span class="p">;</span>  <span class="c1"># GF 20101013 fixed typo d*s -&gt;2*d</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="o">-</span><span class="n">d</span> <span class="o">/</span> <span class="n">a</span>
                            <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">f</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># region 0</span>
                    <span class="n">invDet</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">det</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">invDet</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">invDet</span>
                    <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="c1"># region 2</span>
                <span class="n">tmp0</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">d</span>
                <span class="n">tmp1</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">e</span>
                <span class="k">if</span> <span class="n">tmp1</span> <span class="o">&gt;</span> <span class="n">tmp0</span><span class="p">:</span>  <span class="c1"># minimum on edge s+t=1</span>
                    <span class="n">numer</span> <span class="o">=</span> <span class="n">tmp1</span> <span class="o">-</span> <span class="n">tmp0</span>
                    <span class="n">denom</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
                    <span class="k">if</span> <span class="n">numer</span> <span class="o">&gt;=</span> <span class="n">denom</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="mf">1.0</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="mf">0.0</span>
                        <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="n">f</span><span class="p">;</span>  <span class="c1"># GF 20101014 fixed typo 2*b -&gt; 2*d</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="n">numer</span> <span class="o">/</span> <span class="n">denom</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">s</span>
                        <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span>
    
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># minimum on edge s=0</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="k">if</span> <span class="n">tmp1</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span> <span class="o">+</span> <span class="n">f</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">e</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
                            <span class="n">t</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">f</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">t</span> <span class="o">=</span> <span class="o">-</span><span class="n">e</span> <span class="o">/</span> <span class="n">c</span>
                            <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">e</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">f</span>
                            <span class="c1"># of region 2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="c1"># region6</span>
                    <span class="n">tmp0</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">e</span>
                    <span class="n">tmp1</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">d</span>
                    <span class="k">if</span> <span class="n">tmp1</span> <span class="o">&gt;</span> <span class="n">tmp0</span><span class="p">:</span>
                        <span class="n">numer</span> <span class="o">=</span> <span class="n">tmp1</span> <span class="o">-</span> <span class="n">tmp0</span>
                        <span class="n">denom</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
                        <span class="k">if</span> <span class="n">numer</span> <span class="o">&gt;=</span> <span class="n">denom</span><span class="p">:</span>
                            <span class="n">t</span> <span class="o">=</span> <span class="mf">1.0</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span> <span class="o">+</span> <span class="n">f</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">t</span> <span class="o">=</span> <span class="n">numer</span> <span class="o">/</span> <span class="n">denom</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">t</span>
                            <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span>
    
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="mf">0.0</span>
                        <span class="k">if</span> <span class="n">tmp1</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="n">f</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
                                <span class="n">s</span> <span class="o">=</span> <span class="mf">0.0</span>
                                <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">f</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">s</span> <span class="o">=</span> <span class="o">-</span><span class="n">d</span> <span class="o">/</span> <span class="n">a</span>
                                <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">f</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># region 1</span>
                    <span class="n">numer</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">e</span> <span class="o">-</span> <span class="n">b</span> <span class="o">-</span> <span class="n">d</span>
                    <span class="k">if</span> <span class="n">numer</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="mf">0.0</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="mf">1.0</span>
                        <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span> <span class="o">+</span> <span class="n">f</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">denom</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
                        <span class="k">if</span> <span class="n">numer</span> <span class="o">&gt;=</span> <span class="n">denom</span><span class="p">:</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="mf">1.0</span>
                            <span class="n">t</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="n">f</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="n">numer</span> <span class="o">/</span> <span class="n">denom</span>
                            <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">s</span>
                            <span class="n">sqrdistance</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span>
    
        <span class="c1"># account for numerical round-off error</span>
        <span class="k">if</span> <span class="n">sqrdistance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sqrdistance</span> <span class="o">=</span> <span class="mi">0</span>
    
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sqrdistance</span><span class="p">)</span>
    
        <span class="n">PP0</span> <span class="o">=</span> <span class="n">B</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">E0</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">E1</span>
        <span class="k">return</span> <span class="n">dist</span><span class="p">,</span> <span class="n">PP0</span></div>


<div class="viewcode-block" id="utils.get_nthread">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.utils.html#nirfasteruff.nirfasteruff.utils.get_nthread">[docs]</a>
    <span class="k">def</span> <span class="nf">get_nthread</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Choose the number of OpenMP threads in CPU solvers</span>
<span class="sd">        </span>
<span class="sd">        On CPUs with no hyperthreading, all physical cores are used</span>
<span class="sd">        Otherwise use min(physical_core, 8), i.e. no more than 8</span>
<span class="sd">        </span>
<span class="sd">        This is heuristically determined to avoid performance loss due to memory bottlenecking</span>
<span class="sd">        </span>
<span class="sd">        Advanced user can directly modify this function to choose the appropriate number of threads</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nthread : int</span>
<span class="sd">            number of OpenMP threads to use in CPU solvers.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">logic_core</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        <span class="n">physical_core</span> <span class="o">=</span> <span class="n">psutil</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logic_core</span><span class="o">==</span><span class="n">physical_core</span><span class="p">:</span>
            <span class="c1"># no hyperthreading, use all physical cores</span>
            <span class="n">nthread</span> <span class="o">=</span> <span class="n">physical_core</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use up to 8 threads to avoid memory bottleneck</span>
            <span class="n">nthread</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">physical_core</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">nthread</span></div>

    
<div class="viewcode-block" id="utils.SolverOptions">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.utils.html#nirfasteruff.nirfasteruff.utils.SolverOptions">[docs]</a>
    <span class="k">class</span> <span class="nc">SolverOptions</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters used by the FEM solvers, Equivalent to &#39;solver_options&#39; in the Matlab version</span>
<span class="sd">        </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        max_iter: int</span>
<span class="sd">            maximum number of iterations allowed. Default: 1000</span>
<span class="sd">        AbsoluteTolerance: double</span>
<span class="sd">            Absolute tolerance for convergence. Default: 1e-12</span>
<span class="sd">        RelativeTolerance: double</span>
<span class="sd">            Relative (to the initial residual norm) tolerance for convergence. Default: 1e-12</span>
<span class="sd">        divergence: double</span>
<span class="sd">            Stop the solver when residual norm greater than this value. Default: 1e8</span>
<span class="sd">        GPU: int</span>
<span class="sd">            GPU selection. -1 for automatic, 0, 1, ... for manual selection on multi-GPU systems. Default: -1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">AbsoluteTolerance</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="p">,</span> <span class="n">RelativeTolerance</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="p">,</span> <span class="n">divergence</span> <span class="o">=</span> <span class="mf">1e8</span><span class="p">,</span> <span class="n">GPU</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AbsoluteTolerance</span> <span class="o">=</span> <span class="n">AbsoluteTolerance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RelativeTolerance</span> <span class="o">=</span> <span class="n">RelativeTolerance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">divergence</span> <span class="o">=</span> <span class="n">divergence</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GPU</span> <span class="o">=</span> <span class="n">GPU</span></div>

            
<div class="viewcode-block" id="utils.ConvergenceInfo">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.utils.html#nirfasteruff.nirfasteruff.utils.ConvergenceInfo">[docs]</a>
    <span class="k">class</span> <span class="nc">ConvergenceInfo</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convergence information of the FEM solvers. Only used internally as a return type of functions nirfasteruff.math.get_field_*</span>
<span class="sd">        </span>
<span class="sd">        Constructed using the output of the internal C++ functions</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">            isConverged: bool array</span>
<span class="sd">                if solver converged to relative tolerance, for each rhs</span>
<span class="sd">            isConvergedToAbsoluteTolerance: bool array</span>
<span class="sd">                if solver converged to absolute tolerance, for each rhs</span>
<span class="sd">            iteration: int array</span>
<span class="sd">                iterations taken to converge, for each rhs</span>
<span class="sd">            residual: double array</span>
<span class="sd">                final residual, for each rhs</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">isConverged</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">isConvergedToAbsoluteTolerance</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">info</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">isConverged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">isConverged</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">isConvergedToAbsoluteTolerance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">isConvergedToAbsoluteTolerance</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">iteration</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">residual</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">residual</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="utils.MeshingParams">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.utils.html#nirfasteruff.nirfasteruff.utils.MeshingParams">[docs]</a>
    <span class="k">class</span> <span class="nc">MeshingParams</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters to be used by the CGAL mesher. Note: they should all be double</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">            xPixelSpacing: double</span>
<span class="sd">                voxel distance in x direction. Default: 1.0</span>
<span class="sd">            yPixelSpacing: double</span>
<span class="sd">                voxel distance in y direction. Default: 1.0</span>
<span class="sd">            SliceThickness: double</span>
<span class="sd">                voxel distance in z direction. Default: 1.0</span>
<span class="sd">            facet_angle:double</span>
<span class="sd">                lower bound for the angle (in degrees) of surface facets. Default: 25.0</span>
<span class="sd">            facet_size:double</span>
<span class="sd">                upper bound for the radii of surface Delaunay balls circumscribing the facets. Default: 3.0</span>
<span class="sd">            facet_distance:double</span>
<span class="sd">                upper bound for the distance between the circumcenter of a surface facet and the center of its surface Delaunay ball. Default: 2.0</span>
<span class="sd">            cell_radius_edge:double</span>
<span class="sd">                upper bound for the ratio between the circumradius of a mesh tetrahedron and its shortest edge. Default: 3.0</span>
<span class="sd">            general_cell_size:double</span>
<span class="sd">                upper bound on the circumradii of the mesh tetrahedra, when no region-specific parameters (see below) are provided. Default: 3.0</span>
<span class="sd">            subdomain: double Numpy array</span>
<span class="sd">                Specify cell size for each region, in format::</span>
<span class="sd">                    </span>
<span class="sd">                    [region_label1, cell_size1]</span>
<span class="sd">                    [region_label2, cell_size2]</span>
<span class="sd">                        ...</span>
<span class="sd">                                                    </span>
<span class="sd">                If a region is not specified, value in &quot;general_cell_size&quot; will be used.  Default: np.array([0., 0.])</span>
<span class="sd">            lloyd_smooth: bool</span>
<span class="sd">                Switch for Lloyd smoother before local optimization. This can take up to 120s (hard limit set) but improves mesh quality. Default: True</span>
<span class="sd">            offset: double Numpy array</span>
<span class="sd">                offset value to be added to the nodes after meshing. Size (3,). Defualt: None</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        ----------</span>
<span class="sd">        Refer to CGAL documentation for details of the meshing algorithm as well as its parameters</span>
<span class="sd">        </span>
<span class="sd">        https://doc.cgal.org/latest/Mesh_3/index.html#Chapter_3D_Mesh_Generation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xPixelSpacing</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">yPixelSpacing</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">SliceThickness</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
                                 <span class="n">facet_angle</span> <span class="o">=</span> <span class="mf">25.</span><span class="p">,</span> <span class="n">facet_size</span> <span class="o">=</span> <span class="mf">3.</span><span class="p">,</span> <span class="n">facet_distance</span> <span class="o">=</span> <span class="mf">2.</span><span class="p">,</span>
                                 <span class="n">cell_radius_edge</span> <span class="o">=</span> <span class="mf">3.</span><span class="p">,</span> <span class="n">general_cell_size</span> <span class="o">=</span> <span class="mf">3.</span><span class="p">,</span> <span class="n">subdomain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]),</span>
                                 <span class="n">lloyd_smooth</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xPixelSpacing</span> <span class="o">=</span> <span class="n">xPixelSpacing</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yPixelSpacing</span> <span class="o">=</span> <span class="n">yPixelSpacing</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SliceThickness</span> <span class="o">=</span> <span class="n">SliceThickness</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">facet_angle</span> <span class="o">=</span> <span class="n">facet_angle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">facet_size</span> <span class="o">=</span> <span class="n">facet_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">facet_distance</span> <span class="o">=</span> <span class="n">facet_distance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cell_radius_edge</span> <span class="o">=</span> <span class="n">cell_radius_edge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">general_cell_size</span> <span class="o">=</span> <span class="n">general_cell_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subdomain</span> <span class="o">=</span> <span class="n">subdomain</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smooth</span> <span class="o">=</span> <span class="n">lloyd_smooth</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span></div>
</div>


<div class="viewcode-block" id="io">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.io.html#nirfasteruff.nirfasteruff.io">[docs]</a>
<span class="k">class</span> <span class="nc">io</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Dummy class holding some I/O functions</span>
<span class="sd">    Dummy class used so the function hierarchy can be compatible with the full version</span>
<span class="sd">    &#39;&#39;&#39;</span>
<div class="viewcode-block" id="io.saveinr">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.io.html#nirfasteruff.nirfasteruff.io.saveinr">[docs]</a>
    <span class="k">def</span> <span class="nf">saveinr</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">xPixelSpacing</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">yPixelSpacing</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">SliceThickness</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a volume in the INRIA format. This is for the CGAL mesher.</span>
<span class="sd">        </span>
<span class="sd">        Directly translated from the Matlab version</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vol : NumPy array</span>
<span class="sd">            the volume to be saved.</span>
<span class="sd">        fname : str</span>
<span class="sd">            file name to be saved as.</span>
<span class="sd">        xPixelSpacing : double, optional</span>
<span class="sd">            volume resolution in x direction. The default is 1..</span>
<span class="sd">        yPixelSpacing : double, optional</span>
<span class="sd">            volume resolution in y direction. The default is 1..</span>
<span class="sd">        SliceThickness : double, optional</span>
<span class="sd">            volume resolution in z direction. The default is 1..</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;.inr&#39;</span> <span class="ow">in</span> <span class="n">fname</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">fname</span> <span class="o">+</span> <span class="s1">&#39;.inr&#39;</span>
        <span class="k">if</span> <span class="n">vol</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;bool&#39;</span> <span class="ow">or</span> <span class="n">vol</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;uint8&#39;</span><span class="p">:</span>
            <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;unsigned fixed&#39;</span>
            <span class="n">bitlen</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="k">elif</span> <span class="n">vol</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;uint16&#39;</span><span class="p">:</span>
            <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;unsigned fixed&#39;</span>
            <span class="n">bitlen</span> <span class="o">=</span> <span class="mi">16</span>
        <span class="k">elif</span> <span class="n">vol</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;float32&#39;</span><span class="p">:</span>
            <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;float&#39;</span>
            <span class="n">bitlen</span> <span class="o">=</span> <span class="mi">32</span>
        <span class="k">elif</span> <span class="n">vol</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;float64&#39;</span><span class="p">:</span>
            <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;float&#39;</span>
            <span class="n">bitlen</span> <span class="o">=</span> <span class="mi">64</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;volume format not supported&#39;</span><span class="p">)</span>
            <span class="k">return</span>
            
        <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;#INRIMAGE-4#{</span><span class="se">\n</span><span class="s1">XDIM=</span><span class="si">%d</span><span class="se">\n</span><span class="s1">YDIM=</span><span class="si">%d</span><span class="se">\n</span><span class="s1">ZDIM=</span><span class="si">%d</span><span class="se">\n</span><span class="s1">VDIM=1</span><span class="se">\n</span><span class="s1">TYPE=</span><span class="si">%s</span><span class="se">\n</span><span class="s1">PIXSIZE=</span><span class="si">%d</span><span class="s1"> bits</span><span class="se">\n</span><span class="s1">SCALE=2**0</span><span class="se">\n</span><span class="s1">CPU=decm</span><span class="se">\n</span><span class="s1">VX=</span><span class="si">%f</span><span class="se">\n</span><span class="s1">VY=</span><span class="si">%f</span><span class="se">\n</span><span class="s1">VZ=</span><span class="si">%f</span><span class="se">\n</span><span class="s1">#GEOMETRY=CARTESIAN</span><span class="se">\n</span><span class="s1">&#39;</span> \
                    <span class="o">%</span> <span class="p">(</span><span class="n">vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">btype</span><span class="p">,</span> <span class="n">bitlen</span><span class="p">,</span> <span class="n">xPixelSpacing</span><span class="p">,</span> <span class="n">yPixelSpacing</span><span class="p">,</span> <span class="n">SliceThickness</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)):</span>
            <span class="n">header</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="s1">&#39;##}</span><span class="se">\n</span><span class="s1">&#39;</span>
        
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">vol</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;bool&#39;</span><span class="p">:</span>
                <span class="n">vol</span> <span class="o">=</span> <span class="n">vol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">vol</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">))</span>
        
        <span class="k">return</span></div>

        
<div class="viewcode-block" id="io.readMEDIT">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.io.html#nirfasteruff.nirfasteruff.io.readMEDIT">[docs]</a>
    <span class="k">def</span> <span class="nf">readMEDIT</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a mesh generated by the CGAL mesher, which is saved in MEDIT format</span>
<span class="sd">        </span>
<span class="sd">        Directly translated from the Matlab version</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            name of the file to be loaded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        elements : NumPy array</span>
<span class="sd">            list of elements in the mesh. Zero-based</span>
<span class="sd">        nodes : NumPy array</span>
<span class="sd">            node locations of the mesh, in mm.</span>
<span class="sd">        faces : NumPy array</span>
<span class="sd">            list of faces in the mesh. In case of 2D, it&#39;s the same as elements. Zero-based</span>
<span class="sd">        nnpe : int</span>
<span class="sd">            size of dimension 1 of elements, i.e. 4 for 3D mesh and 3 for 2D mesh.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;.mesh&#39;</span> <span class="ow">in</span> <span class="n">fname</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">fname</span> <span class="o">+</span> <span class="s1">&#39;.mesh&#39;</span>
        <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="n">all_lines</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span><span class="p">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_lines</span><span class="p">)):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">all_lines</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;Vertices&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cur</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="n">line</span> <span class="o">=</span> <span class="n">all_lines</span><span class="p">[</span><span class="n">cur</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nn</span><span class="p">):</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">all_lines</span><span class="p">[</span><span class="n">cur</span><span class="o">+</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">],</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">))</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodes</span><span class="p">)[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Continue reading</span>
        <span class="n">cur</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">+</span><span class="n">nn</span>
        <span class="k">while</span><span class="p">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_lines</span><span class="p">)):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">all_lines</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;Triangles&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">tri</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="s1">&#39;Tetrahedra&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">tet</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cur</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="n">tri</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">all_lines</span><span class="p">[</span><span class="n">cur</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">faces</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
                <span class="n">faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">all_lines</span><span class="p">[</span><span class="n">cur</span><span class="o">+</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">))</span>
            <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span>
            <span class="n">cur</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">+</span><span class="n">nt</span>
            <span class="k">while</span><span class="p">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_lines</span><span class="p">)):</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">all_lines</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span>
                <span class="k">if</span> <span class="s1">&#39;Tetrahedra&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">tet</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cur</span> <span class="o">+=</span> <span class="mi">1</span>
                    
        <span class="c1"># Read the tetrahedrons</span>
        <span class="k">if</span> <span class="n">tet</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">all_lines</span><span class="p">[</span><span class="n">cur</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ne</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ne</span><span class="p">):</span>
                <span class="n">elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">all_lines</span><span class="p">[</span><span class="n">cur</span><span class="o">+</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">))</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>
            <span class="n">nnpe</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="n">faces</span>
            <span class="n">nnpe</span> <span class="o">=</span> <span class="mi">3</span>
            
        <span class="k">return</span> <span class="n">elements</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">nnpe</span></div>
</div>

    
        
<div class="viewcode-block" id="meshing">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.meshing.html#nirfasteruff.nirfasteruff.meshing">[docs]</a>
<span class="k">class</span> <span class="nc">meshing</span><span class="p">:</span>
<div class="viewcode-block" id="meshing.RunCGALMeshGenerator">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.meshing.html#nirfasteruff.nirfasteruff.meshing.RunCGALMeshGenerator">[docs]</a>
    <span class="k">def</span> <span class="nf">RunCGALMeshGenerator</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">opt</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">MeshingParams</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a tetrahedral mesh from a volume using CGAL 6.0.1 mesher, where different regions are labeled used a distinct integer.</span>
<span class="sd">        </span>
<span class="sd">        Internallly, the function makes a system call to the mesher binary, which can also be used standalone through the command line.</span>
<span class="sd">        </span>
<span class="sd">        Also runs a pruning steps after the mesh generation, where nodes not referred to in the element list are removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mask : uint8 NumPy array</span>
<span class="sd">            3D volumetric data defining the space to mesh. Regions defined by different integers. 0 is background.</span>
<span class="sd">        opt : nirfasteruff.utils.MeshingParams, optional</span>
<span class="sd">            meshing parameters used. Default values will be used if not specified.</span>
<span class="sd">            </span>
<span class="sd">            See :func:`nirfasteruff.utils.MeshingParams` for details</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ele : int NumPy array</span>
<span class="sd">            element list calculated by the mesher, one-based. Last column indicates the region each element belongs to</span>
<span class="sd">        nodes : double NumPy array</span>
<span class="sd">            element list calculated by the mesher, in mm.</span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        -------</span>
<span class="sd">        https://doc.cgal.org/latest/Mesh_3/index.html#Chapter_3D_Mesh_Generation</span>

<span class="sd">        &quot;&quot;&quot;</span>
       
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="s1">&#39;uint8&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: CGAL only supports uint8. I am doing the conversion now, but this can lead to unexpected errors!&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        
        <span class="n">tmpmeshfn</span> <span class="o">=</span> <span class="s1">&#39;._out.mesh&#39;</span>
        <span class="n">tmpinrfn</span> <span class="o">=</span> <span class="s1">&#39;._cgal_mesh.inr&#39;</span>
        <span class="n">tmpcritfn</span> <span class="o">=</span> <span class="s1">&#39;._criteria.txt&#39;</span>

        <span class="c1"># Save the tmp INRIA file</span>
        <span class="n">io</span><span class="o">.</span><span class="n">saveinr</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">tmpinrfn</span><span class="p">)</span>
        
        <span class="c1"># save the tmp criteria file</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">tmpcritfn</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">facet_angle</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">facet_size</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">facet_distance</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">cell_radius_edge</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">general_cell_size</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">smooth</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">opt</span><span class="o">.</span><span class="n">subdomain</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">subdomain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">subdomain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">subdomain</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">subdomain</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="c1"># call the mesher</span>
        <span class="n">binpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">nirfasteruff_cpu</span><span class="o">.</span><span class="vm">__file__</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;Darwin&#39;</span><span class="p">:</span>
            <span class="n">mesherbin</span> <span class="o">=</span> <span class="n">binpath</span> <span class="o">+</span> <span class="s1">&#39;/cgalmesherMAC&#39;</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">mesherbin</span><span class="p">,</span> <span class="n">tmpinrfn</span><span class="p">,</span> <span class="n">tmpmeshfn</span><span class="p">,</span> <span class="n">tmpcritfn</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;Linux&#39;</span><span class="p">:</span>
            <span class="n">mesherbin</span> <span class="o">=</span> <span class="n">binpath</span> <span class="o">+</span> <span class="s1">&#39;/cgalmesherLINUX&#39;</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">mesherbin</span><span class="p">,</span> <span class="n">tmpinrfn</span><span class="p">,</span> <span class="n">tmpmeshfn</span><span class="p">,</span> <span class="n">tmpcritfn</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;Windows&#39;</span><span class="p">:</span>
            <span class="n">mesherbin</span> <span class="o">=</span> <span class="n">binpath</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">cgalmesher.exe&#39;</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">mesherbin</span><span class="p">,</span> <span class="n">tmpinrfn</span><span class="p">,</span> <span class="n">tmpmeshfn</span><span class="p">,</span> <span class="n">tmpcritfn</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unsupported operating system: &#39;</span><span class="o">+</span><span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">())</span>
        <span class="n">status</span><span class="o">.</span><span class="n">check_returncode</span><span class="p">()</span>
        <span class="c1"># read result and cleanup</span>
        <span class="n">ele_raw</span><span class="p">,</span> <span class="n">nodes_raw</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">readMEDIT</span><span class="p">(</span><span class="n">tmpmeshfn</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">offset</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">nodes_raw</span> <span class="o">=</span> <span class="n">nodes_raw</span> <span class="o">+</span> <span class="n">opt</span><span class="o">.</span><span class="n">offset</span>
        
        <span class="n">ele_tmp</span> <span class="o">=</span> <span class="n">ele_raw</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nids</span><span class="p">,</span> <span class="n">ele</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ele_tmp</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ele</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># to one-based</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes_raw</span><span class="p">[</span><span class="n">nids</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
        <span class="n">ele</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">ele</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)),</span> <span class="n">ele_raw</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nodes_raw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; Removed </span><span class="si">%d</span><span class="s1"> unused nodes from mesh!</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nodes_raw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">flush</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># remove the tmpfiles</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tmpmeshfn</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tmpinrfn</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tmpcritfn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ele</span><span class="p">,</span> <span class="n">nodes</span></div>
</div>

                

<div class="viewcode-block" id="base">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base">[docs]</a>
<span class="k">class</span> <span class="nc">base</span><span class="p">:</span>  
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Dummy class holding the core classes</span>
<span class="sd">    Dummy class used so the function hierarchy can be compatible with the full version</span>
<span class="sd">    &#39;&#39;&#39;</span>    
<div class="viewcode-block" id="base.FDdata">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.FDdata">[docs]</a>
    <span class="k">class</span> <span class="nc">FDdata</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class holding FD/CW data.</span>
<span class="sd">        </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        phi: double Numpy array</span>
<span class="sd">            Fluence from each source. If mesh contains non-tempty field vol, this will be represented on the grid. Last dimension has the size of the number of sources</span>
<span class="sd">        complex: double or complex double Numpy vector</span>
<span class="sd">            Complex amplitude of each channel. Same as amplitude in case of CW data</span>
<span class="sd">        link: int32 NumPy array</span>
<span class="sd">            Defining all the channels (i.e. source-detector pairs). Copied from mesh.link</span>
<span class="sd">        amplitude: double Numpy vector</span>
<span class="sd">            Absolute amplitude of each channel. I.e. amplitude=abs(complex)</span>
<span class="sd">        phase: double Numpy vector</span>
<span class="sd">            phase data of each channel. All zero in case of CW data</span>
<span class="sd">        vol: nirfaseterff.base.meshvol</span>
<span class="sd">            Information needed to convert between volumetric and mesh space. Copied from mesh.vol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">complex</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">link</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phase</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vol</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">meshvol</span><span class="p">()</span>
            
<div class="viewcode-block" id="base.FDdata.togrid">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.FDdata.togrid">[docs]</a>
        <span class="k">def</span> <span class="nf">togrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Convert data to volumetric space as is defined in mesh.vol. If it is empty, the function does nothing.</span>
<span class="sd">            </span>
<span class="sd">            If data is already in volumetric space, function casts data to the new volumetric space</span>
<span class="sd">            </span>
<span class="sd">            CAUTION: This OVERRIDES the field phi</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            mesh : nirfasteruff.base.stndmesh</span>
<span class="sd">                mesh whose .vol attribute is used to do the conversion.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">xgrid</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">xgrid</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: data already in volumetric space. Recasted to the new volume.&#39;</span><span class="p">)</span>
                    <span class="n">phi_mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">grid2mesh</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">zgrid</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">mesh2grid</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi_mesh</span><span class="p">),</span> <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">ygrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">xgrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">zgrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">mesh2grid</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi_mesh</span><span class="p">),</span> <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">ygrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">xgrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">zgrid</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">mesh2grid</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">),</span> <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">ygrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">xgrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">zgrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">mesh2grid</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">),</span> <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">ygrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">xgrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                
                <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="n">tmp</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vol</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: no converting information found. Ignored. Please run mesh.gen_intmat() first.&#39;</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="base.FDdata.tomesh">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.FDdata.tomesh">[docs]</a>
        <span class="k">def</span> <span class="nf">tomesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Convert data back to mesh space using information defined in mesh.vol. If data.vol is empty, the function does nothing.</span>
<span class="sd">            </span>
<span class="sd">            CAUTION: This OVERRIDES the field phi</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            mesh : nirfasteruff.base.stndmesh</span>
<span class="sd">                mesh whose .vol attribute is used to do the conversion.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isvol</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: data already in mesh space. Ignored.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">grid2mesh</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vol</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">meshvol</span><span class="p">()</span></div>

        
<div class="viewcode-block" id="base.FDdata.isvol">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.FDdata.isvol">[docs]</a>
        <span class="k">def</span> <span class="nf">isvol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Checks if data is in volumetric space.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            bool</span>
<span class="sd">                True if data is in volumetric space, False if not.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">xgrid</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span></div>
</div>

    
<div class="viewcode-block" id="base.optode">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.optode">[docs]</a>
    <span class="k">class</span> <span class="nc">optode</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class for NIRFASTer optodes, which can be either a group of sources or a group of detectors. </span>
<span class="sd">        </span>
<span class="sd">        Note: The field fwhm for sources in the Matlab version has been dropped.</span>
<span class="sd">        </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">            fixed: bool like</span>
<span class="sd">                whether an optode is fixed. </span>
<span class="sd">                </span>
<span class="sd">                If not, it will be moved to one scattering length inside the surface (source) or on the surface (detector).</span>
<span class="sd">                </span>
<span class="sd">                Default: 0</span>
<span class="sd">            num: double NumPy vector</span>
<span class="sd">                indexing of the optodes, starting from one (1,2,3,...)</span>
<span class="sd">            coord: double NumPy array</span>
<span class="sd">                each row is the location of an optode. Unit: mm</span>
<span class="sd">            int_func: double NumPy array</span>
<span class="sd">                First column is the index (one-based) of the element each optode is in. </span>
<span class="sd">                </span>
<span class="sd">                The subsequent columns are the barycentric coordinates (i.e. integration function) in the correponding elements. Size (N, dim+2). </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span> <span class="o">=</span> <span class="p">[]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixed</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">int_func</span> <span class="o">=</span> <span class="p">[]</span>
            
<div class="viewcode-block" id="base.optode.move_sources">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.optode.move_sources">[docs]</a>
        <span class="k">def</span> <span class="nf">move_sources</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Moves sources to the appropriate locations in the mesh.</span>
<span class="sd">            </span>
<span class="sd">            For each source, first move it to the closest point on the surface of the mesh, and then move inside by one scattering length along surface normal.</span>
<span class="sd">            </span>
<span class="sd">            where scattering length is :math:`1/\mu_s&#39;`</span>
<span class="sd">            </span>
<span class="sd">            Integration functions are also calculated after moving.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            mesh : NIRFASTer mesh type</span>
<span class="sd">                The mesh on which the sources are installed. Should be a &#39;stndmesh&#39;, either 2D or 3D</span>

<span class="sd">            Raises</span>
<span class="sd">            ------</span>
<span class="sd">            TypeError</span>
<span class="sd">                If mesh type is not recognized.</span>
<span class="sd">            ValueError</span>
<span class="sd">                If mesh.elements does not have 3 or 4 columns, or mesh.dimension is not 2 or 3.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;stnd&#39;</span><span class="p">:</span>
                <span class="n">mus_eff</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mus</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;mesh type: &#39;</span><span class="o">+</span><span class="n">mesh</span><span class="o">.</span><span class="n">type</span><span class="o">+</span><span class="s1">&#39; unsupported&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: no optodes to move&#39;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mus_eff</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Source cannot be moved. No optical property found.&#39;</span><span class="p">)</span>
                <span class="k">return</span>
            
            <span class="n">scatt_dist</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mus_eff</span><span class="p">)</span>
            <span class="n">mesh_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">scatt_dist</span><span class="o">*</span><span class="mf">10.</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mesh_size</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Mesh is too small for the scattering coefficient given. Minimal mesh size: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mesh_size</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">+</span> <span class="s1">&#39;mm. Scattering distance: &#39;</span>
                      <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">scatt_dist</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;mm. &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mesh_size</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">/</span><span class="mf">10.</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; mm will be used for scattering distance. </span><span class="se">\n</span><span class="s1"> You might want to ensure that the scale of your mesh and the scattering coefficient are in mm.&#39;</span><span class="p">)</span>
                <span class="n">scatt_dist</span> <span class="o">=</span> <span class="n">mesh_size</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">/</span><span class="mf">10.</span>
            
            <span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">mask_touch_surface</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">elements</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="c1"># Get all faces that touch the boundary</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask_touch_surface</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])],</span> 
                              <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask_touch_surface</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])],</span>
                              <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask_touch_surface</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])],</span>
                              <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask_touch_surface</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])]]</span>
                <span class="c1"># sort vertex indices to make them comparable</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span>
                <span class="c1"># take unique faces</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1">#take faces where all three vertices are on the boundary</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">faces</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">mesh</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># convert to zero-based</span>
            <span class="k">elif</span> <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">mask_touch_surface</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">elements</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="c1"># Get all faces that touch the boundary</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask_touch_surface</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])],</span> 
                              <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask_touch_surface</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])],</span>
                              <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask_touch_surface</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])]]</span>
                <span class="c1"># sort vertex indices to make them comparable</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span>
                <span class="c1"># take unique faces</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># take edges where both two vertices are on the boundary</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">faces</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">mesh</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># convert to zero-based</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;mesh.elements has wrong dimensions&#39;</span><span class="p">)</span>
            
            <span class="n">pos1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">pos2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">int_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">dimension</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># find the closest boundary node</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="mf">1000.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">r0_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                    <span class="c1"># find edges including the closest boundary node</span>
                    <span class="n">fi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">faces</span><span class="o">==</span><span class="n">r0_ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="c1"># find closest edge</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">fi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">fi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">pointLineDistance</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">],:],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">],:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">smallest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                    
                    <span class="c1"># find norm of that edge</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="n">smallest</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="n">smallest</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">:]</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    
                    <span class="c1"># move inside by 1 scattering distance</span>
                    <span class="n">pos1</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="n">smallest</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="n">scatt_dist</span>
                    <span class="n">pos2</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="n">smallest</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">n</span> <span class="o">*</span> <span class="n">scatt_dist</span>
                <span class="k">elif</span> <span class="n">mesh</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="c1"># find the closest boundary node</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="mf">1000.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">r0_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                    <span class="c1"># find edges including the closest boundary node</span>
                    <span class="n">fi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">faces</span><span class="o">==</span><span class="n">r0_ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="c1"># find closest edge</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">fi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">fi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">pointTriangleDistance</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">],:],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">],:],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">],:]]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
                    <span class="n">smallest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                    
                    <span class="c1"># find norm of that edge</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="n">smallest</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="n">smallest</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">:]</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="n">smallest</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">:]</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    
                    <span class="c1"># move inside by 1 scattering distance</span>
                    <span class="n">pos1</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="n">smallest</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="n">scatt_dist</span>
                    <span class="n">pos2</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="n">smallest</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">n</span> <span class="o">*</span> <span class="n">scatt_dist</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;mesh.dimension should be 2 or 3&#39;</span><span class="p">)</span>
            
            <span class="n">ind</span><span class="p">,</span> <span class="n">int_func</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">pointLocation</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">pos1</span><span class="p">)</span>
            <span class="n">in_ind</span> <span class="o">=</span> <span class="n">ind</span><span class="o">&gt;-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">in_ind</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">pos1</span><span class="p">[</span><span class="n">in_ind</span><span class="p">,:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">int_func</span><span class="p">[</span><span class="n">in_ind</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">in_ind</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">int_func</span><span class="p">[</span><span class="n">in_ind</span><span class="p">,:]]</span>  <span class="c1"># to one-based</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">in_ind</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nan_ind</span> <span class="o">=</span> <span class="o">~</span><span class="n">in_ind</span>
                <span class="n">ind2</span><span class="p">,</span> <span class="n">int_func2</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">pointLocation</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">pos2</span><span class="p">[</span><span class="n">nan_ind</span><span class="p">,:])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">nan_ind</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">pos2</span><span class="p">[</span><span class="n">nan_ind</span><span class="p">,</span> <span class="p">:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">int_func</span><span class="p">[</span><span class="n">nan_ind</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">ind2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">int_func2</span><span class="p">]</span> <span class="c1"># to one-based</span>
            
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ind2</span><span class="o">==-</span><span class="mi">1</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Source(s) could not be moved. The mesh structure may be poor.&#39;</span><span class="p">)</span></div>

            
        
<div class="viewcode-block" id="base.optode.move_detectors">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.optode.move_detectors">[docs]</a>
        <span class="k">def</span> <span class="nf">move_detectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Moves detector to the appropriate locations in the mesh.</span>
<span class="sd">            </span>
<span class="sd">            For each detector, first move it to the closest point on the surface of the mesh.</span>
<span class="sd">            </span>
<span class="sd">            Integration functions are NOT calculated after moving, to be consistent with the Matlab version.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            mesh : NIRFASTer mesh type</span>
<span class="sd">                The mesh on which the detectors are installed. Should be a &#39;stndmesh&#39;, either 2D or 3D</span>

<span class="sd">            Raises</span>
<span class="sd">            ------</span>
<span class="sd">            ValueError</span>
<span class="sd">                If mesh.elements does not have 3 or 4 columns, or mesh.dimension is not 2 or 3.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: no optodes to move&#39;</span><span class="p">)</span>
                <span class="k">return</span>
            
            <span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">mask_touch_surface</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">elements</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="c1"># Get all faces that touch the boundary</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask_touch_surface</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])],</span> 
                              <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask_touch_surface</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])],</span>
                              <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask_touch_surface</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])],</span>
                              <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask_touch_surface</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])]]</span>
                <span class="c1"># sort vertex indices to make them comparable</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span>
                <span class="c1"># take unique faces</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1">#take faces where all three vertices are on the boundary</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">faces</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">mesh</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># convert to zero-based</span>
            <span class="k">elif</span> <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">mask_touch_surface</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">elements</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="c1"># Get all faces that touch the boundary</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask_touch_surface</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])],</span> 
                              <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask_touch_surface</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])],</span>
                              <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask_touch_surface</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])]]</span>
                <span class="c1"># sort vertex indices to make them comparable</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span>
                <span class="c1"># take unique faces</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># take edges where both two vertices are on the boundary</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">faces</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">mesh</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># convert to zero-based</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;mesh.elements has wrong dimensions&#39;</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># find the closest boundary node</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="mf">1000.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">r0_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                    <span class="c1"># find edges including the closest boundary node</span>
                    <span class="n">fi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">faces</span><span class="o">==</span><span class="n">r0_ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="c1"># find closest edge</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">fi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">fi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">pointLineDistance</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">],:],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">],:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">smallest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                    <span class="c1"># move detector to the closest point on that edge</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="n">smallest</span><span class="p">,:]</span>
                <span class="k">elif</span> <span class="n">mesh</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="c1"># find the closest boundary node</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="mf">1000.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">r0_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                    <span class="c1"># find edges including the closest boundary node</span>
                    <span class="n">fi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">faces</span><span class="o">==</span><span class="n">r0_ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="c1"># find closest edge</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">fi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">fi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">pointTriangleDistance</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">],:],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">],:],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">],:]]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
                    <span class="n">smallest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                    <span class="c1"># move detector to the closest point on that edge</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="n">smallest</span><span class="p">,:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;mesh.dimension should be 2 or 3&#39;</span><span class="p">)</span></div>

            
        
<div class="viewcode-block" id="base.optode.touch_sources">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.optode.touch_sources">[docs]</a>
        <span class="k">def</span> <span class="nf">touch_sources</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Recalculate/fill in all other fields based on &#39;fixed&#39; and &#39;coord&#39;. </span>
<span class="sd">            </span>
<span class="sd">            This is useful when a set of sources are manually added and only the locations are specified.</span>
<span class="sd">            </span>
<span class="sd">            For non-fixed sources, function &#39;move_sources&#39; is called, otherwise recalculates integration functions directly</span>
<span class="sd">            </span>
<span class="sd">            If no source locations are specified, the function does nothing</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            mesh : NIRFASTer mesh type</span>
<span class="sd">                The mesh on which the sources are installed. Should be a &#39;stndmesh&#39;, either 2D or 3D</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">n_src</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_src</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">move_sources</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ind</span><span class="p">,</span> <span class="n">int_func</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">pointLocation</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">int_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">int_func</span><span class="p">]</span></div>

        
<div class="viewcode-block" id="base.optode.touch_detectors">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.optode.touch_detectors">[docs]</a>
        <span class="k">def</span> <span class="nf">touch_detectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Recalculate/fill in all other fields based on &#39;fixed&#39; and &#39;coord&#39;. </span>
<span class="sd">            </span>
<span class="sd">            This is useful when a set of detectors are manually added and only the locations are specified.</span>
<span class="sd">            </span>
<span class="sd">            For non-fixed detectors, function &#39;move_detectors&#39; is first called, and integration functions are calculated subsequentely.</span>
<span class="sd">            </span>
<span class="sd">            For fixed detectors, recalculates integration functions directly.</span>
<span class="sd">            </span>
<span class="sd">            If no detector locations are specified, the function does nothing</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            mesh : NIRFASTer mesh type</span>
<span class="sd">                The mesh on which the sources are installed. Should be a &#39;stndmesh&#39;, either 2D or 3D</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">n_det</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_det</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">move_detectors</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="n">ind</span><span class="p">,</span> <span class="n">int_func</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">pointLocation</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">int_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">int_func</span><span class="p">]</span></div>
</div>

    
<div class="viewcode-block" id="base.meshvol">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.meshvol">[docs]</a>
    <span class="k">class</span> <span class="nc">meshvol</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Small class holding the information needed for converting between mesh and volumetric space. Values calculated by nirfasteruff.base.*mesh.gen_intmat</span>
<span class="sd">        </span>
<span class="sd">        Note that the volumetric space, defined by xgrid, ygrid, and zgrid (empty for 2D mesh), must be uniform</span>
<span class="sd">        </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">            xgrid: double Numpy array</span>
<span class="sd">                x grid of the volumetric space. In mm</span>
<span class="sd">            ygrid: double Numpy array</span>
<span class="sd">                y grid of the volumetric space. In mm</span>
<span class="sd">            zgrid: double Numpy array</span>
<span class="sd">                z grid of the volumetric space. In mm. Empty for 2D meshes</span>
<span class="sd">            mesh2grid: double CSR sparse matrix</span>
<span class="sd">                matrix converting a vector in mesh space to volumetric space, done by mesh2grid.dot(data)</span>
<span class="sd">                </span>
<span class="sd">                The result is vectorized in &#39;F&#39; (Matlab) order</span>
<span class="sd">                </span>
<span class="sd">                Size: (len(xgrid)*len(ygrid)*len(zgrid), NNodes)</span>
<span class="sd">            gridinmesh: int32 NumPy array</span>
<span class="sd">                indices (one-based) of data points in the volumetric space that are within the mesh space, vectorized in &#39;F&#39; order.</span>
<span class="sd">            res: double NumPy array</span>
<span class="sd">                resolution in x, y, z (if 3D) direction, in mm. Size (2,) or (3,)</span>
<span class="sd">            grid2mesh: double CSR sparse matrix</span>
<span class="sd">                matrix converting volumetric data, vectorized in &#39;F&#39; order, to mesh space. Done by grid2mesh.dot(data)</span>
<span class="sd">                </span>
<span class="sd">                Size (Nnodes, len(xgrid)*len(ygrid)*len(ygrid))</span>
<span class="sd">            meshingrid: int32 NumPy array</span>
<span class="sd">                indices (one-based) of data points in the mesh space that are within the volumetric space</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xgrid</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ygrid</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zgrid</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh2grid</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gridinmesh</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid2mesh</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshingrid</span> <span class="o">=</span> <span class="p">[]</span></div>

    
<div class="viewcode-block" id="base.stndmesh">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.stndmesh">[docs]</a>
    <span class="k">class</span> <span class="nc">stndmesh</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Main class for standard mesh. The methods should cover most of the commonly-used functionalities</span>
<span class="sd">        </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">            name: str</span>
<span class="sd">                name of the mesh. Default: &#39;EmptyMesh&#39;</span>
<span class="sd">            nodes: double NumPy array</span>
<span class="sd">                locations of nodes in the mesh. Unit: mm. Size (NNodes, dim)</span>
<span class="sd">            bndvtx: double NumPy array</span>
<span class="sd">                indicator of whether a node is at boundary (1) or internal (0). Size (NNodes,)</span>
<span class="sd">            type: str</span>
<span class="sd">                type of the mesh. It is always &#39;stnd&#39;.</span>
<span class="sd">            mua: double NumPy array</span>
<span class="sd">                absorption coefficient (mm^-1) at each node. Size (NNodes,)</span>
<span class="sd">            kappa: double NumPy array </span>
<span class="sd">                diffusion coefficient (mm) at each node. Size (NNodes,). Defined as 1/(3*(mua + mus))</span>
<span class="sd">            ri: double NumPy array </span>
<span class="sd">                refractive index at each node. Size (NNodes,)</span>
<span class="sd">            mus:(double NumPy array </span>
<span class="sd">                reduced scattering coefficient (mm^-1) at each node. Size (NNodes,)</span>
<span class="sd">            elements: double NumPy array </span>
<span class="sd">                triangulation (tetrahedrons or triangles) of the mesh, Size (NElements, dim+1)</span>
<span class="sd">                </span>
<span class="sd">                Row i contains the indices of the nodes that form tetrahedron/triangle i</span>
<span class="sd">                </span>
<span class="sd">                One-based indexing for direct interoperatability with the Matlab version</span>
<span class="sd">            region: double NumPy array </span>
<span class="sd">                region labeling of each node. Starting from 1. Size (NNodes,)</span>
<span class="sd">            source: nirfasteruff.base.optode </span>
<span class="sd">                information about the sources</span>
<span class="sd">            meas: nirfasteruff.base.optode</span>
<span class="sd">                information about the the detectors</span>
<span class="sd">            link: int32 NumPy array </span>
<span class="sd">                list of source-detector pairs, i.e. channels. Size (NChannels,3)</span>
<span class="sd">                </span>
<span class="sd">                First column: source; Second column: detector; Third column: active (1) or not (0)</span>
<span class="sd">            c: double NumPy array </span>
<span class="sd">                light speed (mm/sec) at each node.  Size (NNodes,). Defined as c0/ri, where c0 is the light speed in vacuum</span>
<span class="sd">            ksi: double NumPy array </span>
<span class="sd">                photon fluence rate scale factor on the mesh-outside_mesh boundary as derived from Fresenel&#39;s law. Size (NNodes,)</span>
<span class="sd">            element_area: double NumPy array </span>
<span class="sd">                volume/area (mm^3 or mm^2) of each element. Size (NElements,)</span>
<span class="sd">            support: double NumPy array </span>
<span class="sd">                total volume/area of all the elements each node belongs to. Size (NNodes,)</span>
<span class="sd">            vol: nirfasteruff.base.meshvol </span>
<span class="sd">                object holding information for converting between mesh and volumetric space.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;EmptyMesh&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bndvtx</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s1">&#39;stnd&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mua</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ri</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mus</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">optode</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meas</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">optode</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">link</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ksi</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">element_area</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vol</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">meshvol</span><span class="p">()</span>
        
<div class="viewcode-block" id="base.stndmesh.from_copy">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.stndmesh.from_copy">[docs]</a>
        <span class="k">def</span> <span class="nf">from_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Deep copy all fields from another mesh.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            mesh : nirfasteruff.base.stndmesh</span>
<span class="sd">                the mesh to copy from.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bndvtx</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s1">&#39;stnd&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mua</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">mua</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">kappa</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ri</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">ri</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mus</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">mus</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meas</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">meas</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">link</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ksi</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">ksi</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">element_area</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">element_area</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">support</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vol</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="base.stndmesh.from_file">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.stndmesh.from_file">[docs]</a>
        <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Read from classic NIRFAST mesh (ASCII) format, not checking the correctness of the loaded integration functions.</span>
<span class="sd">            </span>
<span class="sd">            All fields after loading should be directly compatible with Matlab version.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            file : str</span>
<span class="sd">                name of the mesh. Any extension will be ignored.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None.</span>
<span class="sd">            </span>
<span class="sd">            Examples</span>
<span class="sd">            -------</span>
<span class="sd">            &gt;&gt;&gt; mesh = nirfasteruff.base.stndmesh()</span>
<span class="sd">            &gt;&gt;&gt; mesh.from_file(&#39;meshname&#39;)</span>

<span class="sd">            &quot;&quot;&quot;</span>
            
            <span class="k">if</span> <span class="s1">&#39;.mat&#39;</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: seemingly you are trying to load a mat file. Please use .from_mat method instead&#39;</span><span class="p">)</span>
            <span class="c1"># clear data</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
            <span class="n">file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">file</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># in case an extension is accidentally included</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">file</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Read the nodes</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.node&#39;</span><span class="p">):</span>
                <span class="n">fullname</span> <span class="o">=</span> <span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.node&#39;</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bndvtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: &#39;</span> <span class="o">+</span> <span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.node file is not present&#39;</span><span class="p">)</span>

            <span class="c1"># Read the parameters</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.param&#39;</span><span class="p">):</span>
                <span class="n">fullname</span> <span class="o">=</span> <span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.param&#39;</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">paramfile</span><span class="p">:</span>
                    <span class="n">header</span> <span class="o">=</span> <span class="n">paramfile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;=</span><span class="mi">48</span> <span class="ow">and</span> <span class="nb">ord</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&lt;=</span><span class="mi">57</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: header missing in .param file. You are probably using the old format, which is no longer supported&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="s1">&#39;stnd&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">header</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: the mesh you are trying to load is not a standard mesh&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">skip_header</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mua</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mus</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="p">)</span><span class="o">/</span><span class="mf">3.</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mua</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: &#39;</span> <span class="o">+</span> <span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.param file is not present&#39;</span><span class="p">)</span>
            <span class="c1"># Read the elements</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.elem&#39;</span><span class="p">):</span>
                <span class="n">fullname</span> <span class="o">=</span> <span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.elem&#39;</span>
                <span class="n">ele</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">ele</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span>
                <span class="n">ele</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">check_element_orientation_2d</span><span class="p">(</span><span class="n">ele</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: nodes and elements seem to have incompatable dimentions. Are you using an old 2D mesh?&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: &#39;</span> <span class="o">+</span> <span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.elem file is not present&#39;</span><span class="p">)</span>
            <span class="c1"># Read the region information</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.region&#39;</span><span class="p">):</span>
                <span class="n">fullname</span> <span class="o">=</span> <span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.region&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>                    
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: &#39;</span> <span class="o">+</span> <span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.region file is not present&#39;</span><span class="p">)</span>
            <span class="c1"># Read the source file</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.source&#39;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: source file is not present&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fullname</span> <span class="o">=</span> <span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.source&#39;</span>
                <span class="n">errorflag</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">srcfile</span><span class="p">:</span>
                    <span class="n">hdr1</span> <span class="o">=</span> <span class="n">srcfile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                    <span class="n">hdr2</span> <span class="o">=</span> <span class="n">srcfile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">hdr1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;=</span><span class="mi">48</span> <span class="ow">and</span> <span class="nb">ord</span><span class="p">(</span><span class="n">hdr1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&lt;=</span><span class="mi">57</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: header missing in .source file. You are probably using the old format, which is no longer supported.</span><span class="se">\n</span><span class="s1">Source not loaded&#39;</span><span class="p">)</span>
                    <span class="n">errorflag</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="s1">&#39;num&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hdr1</span> <span class="ow">and</span> <span class="s1">&#39;num&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hdr2</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: Incorrect or old header format.</span><span class="se">\n</span><span class="s1">Source not loaded&#39;</span><span class="p">)</span>
                    <span class="n">errorflag</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="s1">&#39;fixed&#39;</span> <span class="ow">in</span> <span class="n">hdr1</span><span class="p">:</span>
                    <span class="n">fixed</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">N_hdr</span> <span class="o">=</span> <span class="mi">2</span>
                    <span class="n">hdr</span> <span class="o">=</span> <span class="n">hdr2</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fixed</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">N_hdr</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">hdr</span> <span class="o">=</span> <span class="n">hdr1</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">errorflag</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">skip_header</span><span class="o">=</span><span class="n">N_hdr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
                    <span class="n">src</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">optode</span><span class="p">()</span>
                    <span class="n">src</span><span class="o">.</span><span class="n">fixed</span> <span class="o">=</span> <span class="n">fixed</span>
                    <span class="n">src</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="s1">&#39;z&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hdr</span><span class="p">:</span>
                        <span class="n">src</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)],</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">src</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)],</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)],</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)]]</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Sources are 3D, mesh is 2D.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="s1">&#39;fwhm&#39;</span> <span class="ow">in</span> <span class="n">hdr</span><span class="p">:</span>
                        <span class="n">fwhm</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;fwhm&#39;</span><span class="p">)]</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">fwhm</span><span class="p">):</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Only point sources supported. Ignoring field fwhm&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="s1">&#39;ele&#39;</span> <span class="ow">in</span> <span class="n">hdr</span><span class="p">:</span>
                        <span class="k">if</span> <span class="s1">&#39;ip1&#39;</span> <span class="ow">in</span> <span class="n">hdr</span> <span class="ow">and</span> <span class="s1">&#39;ip2&#39;</span> <span class="ow">in</span> <span class="n">hdr</span> <span class="ow">and</span> <span class="s1">&#39;ip3&#39;</span> <span class="ow">in</span> <span class="n">hdr</span><span class="p">:</span>
                            <span class="n">src</span><span class="o">.</span><span class="n">int_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;ele&#39;</span><span class="p">)],</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;ip1&#39;</span><span class="p">)],</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;ip2&#39;</span><span class="p">)],</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;ip3&#39;</span><span class="p">)]]</span>
                            <span class="k">if</span> <span class="s1">&#39;ip4&#39;</span> <span class="ow">in</span> <span class="n">hdr</span><span class="p">:</span>
                                <span class="n">src</span><span class="o">.</span><span class="n">int_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">src</span><span class="o">.</span><span class="n">int_func</span><span class="p">,</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;ip4&#39;</span><span class="p">)]]</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Sources &#39;&#39;int_func&#39;&#39; are 3D, mesh is 2D.&#39;</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Sources &#39;&#39;int_func&#39;&#39; are 2D, mesh is 3D. Will recalculate&#39;</span><span class="p">)</span>
                                    <span class="n">src</span><span class="o">.</span><span class="n">int_func</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: source int_func stored in wrong format or missing. Will recalculate&#39;</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">src</span><span class="o">.</span><span class="n">fixed</span><span class="o">==</span><span class="mi">1</span>  <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">int_func</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">src</span><span class="o">.</span><span class="n">fixed</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fixed sources&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">int_func</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sources integration functions loaded&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># non-fixed sources and no int_func loaded. Let&#39;s move the sources by one scattering length now</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Moving Sources&#39;</span><span class="p">,</span> <span class="n">flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">src</span><span class="o">.</span><span class="n">move_sources</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">int_func</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calculating sources integration functions&#39;</span><span class="p">,</span> <span class="n">flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">ind</span><span class="p">,</span> <span class="n">int_func</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">pointLocation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span>
                        <span class="n">src</span><span class="o">.</span><span class="n">int_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">int_func</span><span class="p">]</span>
                    <span class="n">src</span><span class="o">.</span><span class="n">int_func</span><span class="p">[</span><span class="n">src</span><span class="o">.</span><span class="n">int_func</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">src</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">int_func</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: some sources might be outside the mesh&#39;</span><span class="p">)</span>
            <span class="c1"># Read the detector file</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.meas&#39;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: detector file is not present&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fullname</span> <span class="o">=</span> <span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.meas&#39;</span>
                <span class="n">errorflag</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">srcfile</span><span class="p">:</span>
                    <span class="n">hdr1</span> <span class="o">=</span> <span class="n">srcfile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                    <span class="n">hdr2</span> <span class="o">=</span> <span class="n">srcfile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">hdr1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;=</span><span class="mi">48</span> <span class="ow">and</span> <span class="nb">ord</span><span class="p">(</span><span class="n">hdr1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&lt;=</span><span class="mi">57</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: header missing in .meas file. You are probably using the old format, which is no longer supported.</span><span class="se">\n</span><span class="s1">Detector not loaded&#39;</span><span class="p">)</span>
                    <span class="n">errorflag</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="s1">&#39;num&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hdr1</span> <span class="ow">and</span> <span class="s1">&#39;num&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hdr2</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: Incorrect or old header format.</span><span class="se">\n</span><span class="s1">Detector not loaded&#39;</span><span class="p">)</span>
                    <span class="n">errorflag</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="s1">&#39;fixed&#39;</span> <span class="ow">in</span> <span class="n">hdr1</span><span class="p">:</span>
                    <span class="n">fixed</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">N_hdr</span> <span class="o">=</span> <span class="mi">2</span>
                    <span class="n">hdr</span> <span class="o">=</span> <span class="n">hdr2</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fixed</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">N_hdr</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">hdr</span> <span class="o">=</span> <span class="n">hdr1</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">errorflag</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">skip_header</span><span class="o">=</span><span class="n">N_hdr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
                    <span class="n">det</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">optode</span><span class="p">()</span>
                    <span class="n">det</span><span class="o">.</span><span class="n">fixed</span> <span class="o">=</span> <span class="n">fixed</span>
                    <span class="n">det</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="s1">&#39;z&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hdr</span><span class="p">:</span>
                        <span class="n">det</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)],</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">det</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)],</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)],</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)]]</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Detectors are 3D, mesh is 2D.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="s1">&#39;ele&#39;</span> <span class="ow">in</span> <span class="n">hdr</span><span class="p">:</span>
                        <span class="k">if</span> <span class="s1">&#39;ip1&#39;</span> <span class="ow">in</span> <span class="n">hdr</span> <span class="ow">and</span> <span class="s1">&#39;ip2&#39;</span> <span class="ow">in</span> <span class="n">hdr</span> <span class="ow">and</span> <span class="s1">&#39;ip3&#39;</span> <span class="ow">in</span> <span class="n">hdr</span><span class="p">:</span>
                            <span class="n">det</span><span class="o">.</span><span class="n">int_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;ele&#39;</span><span class="p">)],</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;ip1&#39;</span><span class="p">)],</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;ip2&#39;</span><span class="p">)],</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;ip3&#39;</span><span class="p">)]]</span>
                            <span class="k">if</span> <span class="s1">&#39;ip4&#39;</span> <span class="ow">in</span> <span class="n">hdr</span><span class="p">:</span>
                                <span class="n">det</span><span class="o">.</span><span class="n">int_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">det</span><span class="o">.</span><span class="n">int_func</span><span class="p">,</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">hdr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;ip4&#39;</span><span class="p">)]]</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Detectors &#39;&#39;int_func&#39;&#39; are 3D, mesh is 2D.&#39;</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Detectors &#39;&#39;int_func&#39;&#39; are 2D, mesh is 3D. Will recalculate&#39;</span><span class="p">)</span>
                                    <span class="n">det</span><span class="o">.</span><span class="n">int_func</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: detector int_func stored in wrong format. Will recalculate&#39;</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">det</span><span class="o">.</span><span class="n">fixed</span><span class="o">==</span><span class="mi">1</span>  <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">det</span><span class="o">.</span><span class="n">int_func</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">det</span><span class="o">.</span><span class="n">fixed</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fixed detectors&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">det</span><span class="o">.</span><span class="n">int_func</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Detectors integration functions loaded&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># non-fixed sources and no int_func loaded. Let&#39;s move the sources by one scattering length now</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Moving Detectors&#39;</span><span class="p">,</span> <span class="n">flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">det</span><span class="o">.</span><span class="n">move_detectors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">det</span><span class="o">.</span><span class="n">int_func</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calculating detectors integration functions&#39;</span><span class="p">,</span> <span class="n">flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">ind</span><span class="p">,</span> <span class="n">int_func</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">pointLocation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">det</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span>
                        <span class="n">det</span><span class="o">.</span><span class="n">int_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">int_func</span><span class="p">]</span>
                    <span class="n">det</span><span class="o">.</span><span class="n">int_func</span><span class="p">[</span><span class="n">det</span><span class="o">.</span><span class="n">int_func</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">meas</span> <span class="o">=</span> <span class="n">det</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">det</span><span class="o">.</span><span class="n">int_func</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: some detectors might be outside the mesh&#39;</span><span class="p">)</span>
            <span class="c1"># load link list</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.link&#39;</span><span class="p">):</span>
                <span class="n">fullname</span> <span class="o">=</span> <span class="n">file</span> <span class="o">+</span> <span class="s1">&#39;.link&#39;</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">linkfile</span><span class="p">:</span>
                    <span class="n">header</span> <span class="o">=</span> <span class="n">linkfile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;=</span><span class="mi">48</span> <span class="ow">and</span> <span class="nb">ord</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&lt;=</span><span class="mi">57</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: header missing in .link file. You are probably using the old format, which is no longer supported&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="n">skip_header</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: link file is not present&#39;</span><span class="p">)</span>
            <span class="c1"># Speed of light in medium</span>
            <span class="n">c0</span> <span class="o">=</span> <span class="mf">299792458000.0</span> <span class="c1"># mm/s</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">ri</span>
            <span class="c1"># Set boundary coefficient using definition of baundary attenuation A using the Fresenel&#39;s law; Robin type</span>
            <span class="n">n_air</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ri</span><span class="o">/</span><span class="n">n_air</span>
            <span class="n">R0</span> <span class="o">=</span> <span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">R0</span><span class="p">)</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ksi</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="p">)</span>
            <span class="c1"># area and support for each element</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">element_area</span> <span class="o">=</span> <span class="n">nirfasteruff_cpu</span><span class="o">.</span><span class="n">ele_area</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">nirfasteruff_cpu</span><span class="o">.</span><span class="n">mesh_support</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_area</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="base.stndmesh.from_mat">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.stndmesh.from_mat">[docs]</a>
        <span class="k">def</span> <span class="nf">from_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matfile</span><span class="p">,</span> <span class="n">varname</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Read from Matlab .mat file that contains a NIRFASTer mesh struct. All fields copied as is without error checking.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            matfile : str</span>
<span class="sd">                name of the .mat file to load. Use of extension is optional.</span>
<span class="sd">            varname : str, optional</span>
<span class="sd">                if your .mat file contains multiple variables, use this argument to specify which one to load. The default is None.</span>
<span class="sd">                </span>
<span class="sd">                When `varname==None`, `matfile` should contain exatly one structure, which is a NIRFASTer mesh, or the function will do nothing</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">matfile</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;argument 1 must be a string!&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">varname</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;argument 2 must be a string!&#39;</span><span class="p">)</span>
            
            <span class="k">try</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">matfile</span><span class="p">,</span> <span class="n">struct_as_record</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">squeeze_me</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Failed to load Matlab file &#39;</span> <span class="o">+</span> <span class="n">matfile</span> <span class="o">+</span> <span class="s1">&#39;!&#39;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">varname</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">mesh</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Cannot load mesh &#39;</span> <span class="o">+</span> <span class="n">varname</span> <span class="o">+</span> <span class="s1">&#39; from mat file &#39;</span> <span class="o">+</span> <span class="n">matfile</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">allkeys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">is_struct</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">==</span><span class="n">sio</span><span class="o">.</span><span class="n">matlab</span><span class="o">.</span><span class="n">_mio5_params</span><span class="o">.</span><span class="n">mat_struct</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">allkeys</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">is_struct</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;There must be precisely one struct in the mat file, if &quot;varname&quot; is not provided&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">varname</span> <span class="o">=</span> <span class="n">allkeys</span><span class="p">[</span><span class="n">is_struct</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="kc">True</span><span class="p">)]</span>
                    <span class="n">mesh</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span>
                    
            <span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s1">&#39;stnd&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;mesh type must be standard&#39;</span><span class="p">)</span>
            <span class="c1"># Now let&#39;s copy the data</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bndvtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mua</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">mua</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">kappa</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">ri</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">mus</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">dimension</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ksi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">ksi</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">element_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">element_area</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">support</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">allfields</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">_fieldnames</span>
            <span class="k">if</span> <span class="s1">&#39;source&#39;</span> <span class="ow">in</span> <span class="n">allfields</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">fixed</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">fixed</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">num</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">coord</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">int_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">int_func</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: sources are not present in mesh&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;meas&#39;</span> <span class="ow">in</span> <span class="n">allfields</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">fixed</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">fixed</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">num</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">coord</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">int_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">int_func</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: detectors are not present in mesh&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;link&#39;</span> <span class="ow">in</span> <span class="n">allfields</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">link</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: link is not present in mesh&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;vol&#39;</span> <span class="ow">in</span> <span class="n">allfields</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">xgrid</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">xgrid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">ygrid</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">ygrid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">zgrid</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">zgrid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">mesh2grid</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">mesh2grid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">gridinmesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">gridinmesh</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">grid2mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">grid2mesh</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">meshingrid</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">meshingrid</span></div>

                
<div class="viewcode-block" id="base.stndmesh.from_solid">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.stndmesh.from_solid">[docs]</a>
        <span class="k">def</span> <span class="nf">from_solid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ele</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">prop</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">src</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">det</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">link</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Construct a NIRFASTer mesh from a 3D solid mesh generated by a mesher. Similar to the solidmesh2nirfast function in Matlab version.</span>
<span class="sd">            </span>
<span class="sd">            Can also set the optical properties and optodes if supplied</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            ele : int/double NumPy array</span>
<span class="sd">                element list in one-based indexing. If four columns, all nodes will be labeled as region 1</span>
<span class="sd">                </span>
<span class="sd">                If five columns, the last column will be used for region labeling.</span>
<span class="sd">            nodes : double NumPy array</span>
<span class="sd">                node locations in the mesh. Unit: mm. Size (NNodes,3).</span>
<span class="sd">            prop : double NumPy array, optional</span>
<span class="sd">                If not `None`, calls `stndmesh.set_prop()` and sets the optical properties in the mesh. The default is None.</span>
<span class="sd">                </span>
<span class="sd">                See :func:`~nirfasteruff.base.stndmesh.set_prop()` for details. </span>
<span class="sd">            src : nirfasteruff.base.optode, optional</span>
<span class="sd">                If not `None`, sets the sources and moves them to the appropriate locations. The default is None.</span>
<span class="sd">                </span>
<span class="sd">                See :func:`~nirfasteruff.base.optode.touch_sources()` for details.</span>
<span class="sd">            det : nirfasteruff.base.optode, optional</span>
<span class="sd">                If not `None`, sets the detectors and moves them to the appropriate locations. The default is None.</span>
<span class="sd">                </span>
<span class="sd">                See :func:`~nirfasteruff.base.optode.touch_detectors()` for details.</span>
<span class="sd">            link : int32 NumPy array, optional</span>
<span class="sd">                If not `None`, sets the channel information. Uses one-based indexing. The default is None.</span>
<span class="sd">                </span>
<span class="sd">                Each row represents a channel, in the form of `[src, det, active]`, where `active` is 0 or 1</span>
<span class="sd">                </span>
<span class="sd">                If `link` contains only two columns, all channels are considered active.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None.</span>

<span class="sd">            &quot;&quot;&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
            <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="c1"># no region label</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">ele</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ele</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
                <span class="c1"># convert element label to node label</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ele</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">ele</span><span class="p">[</span><span class="n">ele</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">ele</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: elements in wrong format&#39;</span><span class="p">)</span>

            <span class="c1"># find the boundary nodes: find faces that are referred to only once</span>
            <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">ele</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span> 
                          <span class="n">ele</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]],</span>
                          <span class="n">ele</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]],</span>
                          <span class="n">ele</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]]</span>
            
            <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span>
            <span class="n">unique_faces</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">bnd_faces</span> <span class="o">=</span> <span class="n">unique_faces</span><span class="p">[</span><span class="n">cnt</span><span class="o">==</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">bndvtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bnd_faces</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bndvtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bndvtx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">bndvtx</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># area and support for each element</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">element_area</span> <span class="o">=</span> <span class="n">nirfasteruff_cpu</span><span class="o">.</span><span class="n">ele_area</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">nirfasteruff_cpu</span><span class="o">.</span><span class="n">mesh_support</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_area</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prop</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_prop</span><span class="p">(</span><span class="n">prop</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: optical properties not specified&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">src</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">touch_sources</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: no sources specified&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">det</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meas</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">det</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">touch_detectors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: no detectors specified&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">link</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">link</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">link</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">link</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: link in wrong format. Ignored.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: no link specified&#39;</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="base.stndmesh.from_volume">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.stndmesh.from_volume">[docs]</a>
        <span class="k">def</span> <span class="nf">from_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vol</span><span class="p">,</span> <span class="n">param</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">MeshingParams</span><span class="p">(),</span> <span class="n">prop</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">src</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">det</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">link</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Construct mesh from a segmented 3D volume using the built-in CGAL mesher. Calls stndmesh.from_solid after meshing step.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            vol : uint8 NumPy array</span>
<span class="sd">                3D segmented volume to be meshed. 0 is considered as outside. Regions labeled using unique integers.</span>
<span class="sd">            param : nirfasteruff.utils.MeshingParams, optional</span>
<span class="sd">                parameters used in the CGAL mesher. If not specified, uses the default parameters defined in nirfasteruff.utils.MeshingParams().</span>
<span class="sd">                </span>
<span class="sd">                Please modify fields xPixelSpacing, yPixelSpacing, and SliceThickness if your volume doesn&#39;t have [1,1,1] resolution</span>
<span class="sd">                </span>
<span class="sd">                See :func:`~nirfasteruff.utils.MeshingParams()` for details.</span>
<span class="sd">            prop : double NumPy array, optional</span>
<span class="sd">                If not `None`, calls `stndmesh.set_prop()` and sets the optical properties in the mesh. The default is None.</span>
<span class="sd">                </span>
<span class="sd">                See :func:`~nirfasteruff.base.stndmesh.set_prop()` for details. </span>
<span class="sd">            src : nirfasteruff.base.optode, optional</span>
<span class="sd">                If not `None`, sets the sources and moves them to the appropriate locations. The default is None.</span>
<span class="sd">                </span>
<span class="sd">                See :func:`~nirfasteruff.base.optode.touch_sources()` for details.</span>
<span class="sd">            det : nirfasteruff.base.optode, optional</span>
<span class="sd">                If not `None`, sets the detectors and moves them to the appropriate locations. The default is None.</span>
<span class="sd">                </span>
<span class="sd">                See :func:`~nirfasteruff.base.optode.touch_detectors()` for details.</span>
<span class="sd">            link : int32 NumPy array, optional</span>
<span class="sd">                If not `None`, sets the channel information. Uses one-based indexing. The default is None.</span>
<span class="sd">                </span>
<span class="sd">                Each row represents a channel, in the form of `[src, det, active]`, where `active` is 0 or 1</span>
<span class="sd">                </span>
<span class="sd">                If `link` contains only two columns, all channels are considered active.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vol</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: vol should be a 3D matrix in unit8&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running CGAL mesher&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ele</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">meshing</span><span class="o">.</span><span class="n">RunCGALMeshGenerator</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Converting to NIRFAST format&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_solid</span><span class="p">(</span><span class="n">ele</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">det</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="base.stndmesh.set_prop">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.stndmesh.set_prop">[docs]</a>
        <span class="k">def</span> <span class="nf">set_prop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Set optical properties of the whole mesh, using information provided in prop.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            prop : double NumPy array</span>
<span class="sd">                optical property info, similar to the MCX format::</span>
<span class="sd">                    </span>
<span class="sd">                    [region mua(mm-1) musp(mm-1) ri]</span>
<span class="sd">                    [region mua(mm-1) musp(mm-1) ri]</span>
<span class="sd">                    [...]</span>
<span class="sd">                    </span>
<span class="sd">                where &#39;region&#39; is the region label, and they should match exactly with unique(mesh.region). The order doesn&#39;t matter.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">num_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mua</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ksi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">prop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">))</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">prop</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">))):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: regions in mesh and regions in prop matrix mismatch. Ignored.&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">prop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="mi">4</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: prop matrix has wrong number of columns. Should be: region mua(mm-1) musp(mm-1) ri. Ignored&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">prop</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mua</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">==</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">prop</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mus</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">==</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">prop</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ri</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">==</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">prop</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mua</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mus</span><span class="p">))</span>
                <span class="n">c0</span> <span class="o">=</span> <span class="mf">299792458000.0</span> <span class="c1"># mm/s</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">ri</span>
                <span class="n">n_air</span> <span class="o">=</span> <span class="mf">1.</span>
                <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ri</span><span class="o">/</span><span class="n">n_air</span>
                <span class="n">R0</span> <span class="o">=</span> <span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>
                <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">R0</span><span class="p">)</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ksi</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="p">)</span></div>

                
<div class="viewcode-block" id="base.stndmesh.change_prop">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.stndmesh.change_prop">[docs]</a>
        <span class="k">def</span> <span class="nf">change_prop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">prop</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Change optical properties (mua, musp, and ri) at nodes specified in idx, and automatically change fields kappa, c, and ksi as well</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            idx : list or NumPy array or -1</span>
<span class="sd">                zero-based indices of nodes to change. If `idx==-1`, function changes all the nodes</span>
<span class="sd">            prop : list or NumPy array of length 3</span>
<span class="sd">                new optical properties to be assigned to the specified nodes. [mua(mm-1) musp(mm-1) ri].</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">idx</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mua</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">prop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mus</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">prop</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ri</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">prop</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mua</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mus</span><span class="p">))</span>
            <span class="n">c0</span> <span class="o">=</span> <span class="mf">299792458000.0</span> <span class="c1"># mm/s</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">ri</span>
            <span class="n">n_air</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ri</span><span class="o">/</span><span class="n">n_air</span>
            <span class="n">R0</span> <span class="o">=</span> <span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">R0</span><span class="p">)</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ksi</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="base.stndmesh.touch_optodes">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.stndmesh.touch_optodes">[docs]</a>
        <span class="k">def</span> <span class="nf">touch_optodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Moves all optodes (if non fixed) and recalculate the integration functions (i.e. barycentric coordinates). </span>
<span class="sd">            </span>
<span class="sd">            See :func:`~nirfasteruff.base.optode.touch_sources()` and :func:`~nirfasteruff.base.optode.touch_detectors()` for details</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># make sure the optodes sit correctly: moved if needed, calculate the int func</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;touching sources&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">touch_sources</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;touching detectors&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">touch_detectors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="base.stndmesh.save_nirfast">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.stndmesh.save_nirfast">[docs]</a>
        <span class="k">def</span> <span class="nf">save_nirfast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Save mesh in the classic NIRFASTer ASCII format, which is directly compatible with the Matlab version</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            filename : str</span>
<span class="sd">                name of the file to be saved as. Should have no extensions.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            
            <span class="c1"># save nodes</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.node&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bndvtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">],</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%.16g</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># save elements</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.elem&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%g</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># save params</span>
            <span class="n">kappa</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mua</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mus</span><span class="p">))</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.param&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mua</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ri</span><span class="p">],</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%g</span><span class="s1">&#39;</span><span class="p">,</span>
                       <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="s1">&#39;stnd&#39;</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="c1"># save regions</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.region&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%g</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># save sources, if exist</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.source&#39;</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.source&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">int_func</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">int_func</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                        <span class="n">hdr</span> <span class="o">=</span> <span class="s1">&#39;num x y ele ip1 ip2 ip3&#39;</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                        <span class="n">hdr</span> <span class="o">=</span> <span class="s1">&#39;num x y z ele ip1 ip2 ip3 ip4&#39;</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">coord</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">int_func</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                        <span class="n">hdr</span> <span class="o">=</span> <span class="s1">&#39;num x y&#39;</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                        <span class="n">hdr</span> <span class="o">=</span> <span class="s1">&#39;num x y z&#39;</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">coord</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">fixed</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">hdr</span> <span class="o">=</span> <span class="s1">&#39;fixed</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">hdr</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.source&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%.16g</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">hdr</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="c1"># save detectors, if exist</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.meas&#39;</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.meas&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">int_func</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">int_func</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                        <span class="n">hdr</span> <span class="o">=</span> <span class="s1">&#39;num x y ele ip1 ip2 ip3&#39;</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                        <span class="n">hdr</span> <span class="o">=</span> <span class="s1">&#39;num x y z ele ip1 ip2 ip3 ip4&#39;</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">coord</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">int_func</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                        <span class="n">hdr</span> <span class="o">=</span> <span class="s1">&#39;num x y&#39;</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                        <span class="n">hdr</span> <span class="o">=</span> <span class="s1">&#39;num x y z&#39;</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">coord</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">fixed</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">hdr</span> <span class="o">=</span> <span class="s1">&#39;fixed</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">hdr</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.meas&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%.16g</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">hdr</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="c1"># save link, if exist</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.link&#39;</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.link&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hdr</span> <span class="o">=</span> <span class="s1">&#39;source detector active&#39;</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.link&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">link</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%g</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">hdr</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="base.stndmesh.femdata">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.stndmesh.femdata">[docs]</a>
        <span class="k">def</span> <span class="nf">femdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">get_solver</span><span class="p">(),</span> <span class="n">opt</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">SolverOptions</span><span class="p">()):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculates fluences for each source using a FEM solver, and then the boudary measurables for each channel </span>
<span class="sd">            </span>
<span class="sd">            If `mesh.vol` is set, fluence data will be represented in volumetric space</span>
<span class="sd">            </span>
<span class="sd">            See :func:`~nirfasteruff.forward.femdata_stnd_CW()` and :func:`~nirfasteruff.forward.femdata_stnd_FD()` for details</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            freq : double</span>
<span class="sd">                modulation frequency in Hz. If CW, set to zero and a more efficient CW solver will be used.</span>
<span class="sd">            solver : str, optional</span>
<span class="sd">                Choose between &#39;CPU&#39; or &#39;GPU&#39; solver (case insensitive). Automatically determined (GPU prioritized) if not specified</span>
<span class="sd">            opt : nirfasteruff.utils.SolverOptions, optional</span>
<span class="sd">                Solver options. Uses default parameters if not specified, and they should suffice in most cases. </span>
<span class="sd">                </span>
<span class="sd">                See :func:`~nirfasteruff.utils.SolverOptions` for details</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            data : nirfasteruff.base.FDdata</span>
<span class="sd">                fluence and boundary measurables given the mesh and optodes.</span>
<span class="sd">                </span>
<span class="sd">                See :func:`~nirfasteruff.base.FDdata` for details.</span>
<span class="sd">            info : nirfasteruff.utils.ConvergenceInfo</span>
<span class="sd">                convergence information of the solver.</span>
<span class="sd">                </span>
<span class="sd">                See :func:`~nirfasteruff.utils.ConvergenceInfo` for details</span>

<span class="sd">            &quot;&quot;&quot;</span>
            
            <span class="c1"># freq in Hz</span>
            <span class="k">if</span> <span class="n">freq</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">forward</span><span class="o">.</span><span class="n">femdata_stnd_CW</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">,</span> <span class="n">opt</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">info</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">forward</span><span class="o">.</span><span class="n">femdata_stnd_FD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">solver</span><span class="p">,</span> <span class="n">opt</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">info</span></div>

            
<div class="viewcode-block" id="base.stndmesh.isvol">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.stndmesh.isvol">[docs]</a>
        <span class="k">def</span> <span class="nf">isvol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check if convertion matrices between mesh and volumetric spaces are calculated</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            bool</span>
<span class="sd">                True if attribute `.vol` is calculate, False if not.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">xgrid</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span></div>

            
<div class="viewcode-block" id="base.stndmesh.gen_intmat">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.base.html#nirfasteruff.nirfasteruff.base.stndmesh.gen_intmat">[docs]</a>
        <span class="k">def</span> <span class="nf">gen_intmat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xgrid</span><span class="p">,</span> <span class="n">ygrid</span><span class="p">,</span> <span class="n">zgrid</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculate the information needed to convert data between mesh and volumetric space, specified by x, y, z (if 3D) grids.</span>
<span class="sd">            </span>
<span class="sd">            All grids must be uniform. The results will from a nirfasteruff.base.meshvol object stored in field .vol</span>
<span class="sd">            </span>
<span class="sd">            If field .vol already exists, it will be calculated again, and a warning will be thrown</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            xgrid : double NumPy array</span>
<span class="sd">                x grid in mm.</span>
<span class="sd">            ygrid : double NumPy array</span>
<span class="sd">                x grid in mm.</span>
<span class="sd">            zgrid : double NumPy array, optional</span>
<span class="sd">                x grid in mm. Leave empty for 2D meshes. The default is [].</span>
<span class="sd">            </span>
<span class="sd">            Raises</span>
<span class="sd">            ------</span>
<span class="sd">            ValueError</span>
<span class="sd">                if grids not uniform, or zgrid empty for 3D mesh</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">xgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xgrid</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>
            <span class="n">ygrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ygrid</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>
            <span class="n">zgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">zgrid</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xgrid</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tmp</span><span class="o">-</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error: xgrid must be uniform&#39;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ygrid</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tmp</span><span class="o">-</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error: ygrid must be uniform&#39;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zgrid</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">zgrid</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tmp</span><span class="o">-</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error: zgrid must be uniform&#39;</span><span class="p">)</span>
                    <span class="k">return</span>
                
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isvol</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: recalculating intmat&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zgrid</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xgrid</span><span class="p">,</span> <span class="n">ygrid</span><span class="p">)</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">X</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="n">Y</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xgrid</span><span class="p">,</span> <span class="n">ygrid</span><span class="p">,</span> <span class="n">zgrid</span><span class="p">)</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">X</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="n">Y</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="n">Z</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)]</span>
            <span class="c1"># DT = spatial.Delaunay(self.nodes)</span>
            <span class="c1"># ind, int_func = nirfasteruff_cpu.pointLocation(np.float64(DT.simplices+1), DT.points, np.atleast_2d(coords))</span>
            <span class="n">ind</span><span class="p">,</span> <span class="n">int_func</span> <span class="o">=</span> <span class="n">nirfasteruff_cpu</span><span class="o">.</span><span class="n">pointLocation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">coords</span><span class="o">*</span><span class="mf">1.0</span><span class="p">))</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">ind</span><span class="o">&gt;-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This is zero-based</span>
            <span class="n">int_func_inside</span> <span class="o">=</span> <span class="n">int_func</span><span class="p">[</span><span class="n">inside</span><span class="p">,</span> <span class="p">:]</span>
            <span class="c1"># nodes = np.int32(DT.simplices[ind[inside],:])</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">inside</span><span class="p">],:]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">int_mat</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">((</span><span class="n">int_func_inside</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">inside</span><span class="p">,</span> <span class="n">int_func</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">))),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">ind</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">xgrid</span> <span class="o">=</span> <span class="n">xgrid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">ygrid</span> <span class="o">=</span> <span class="n">ygrid</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zgrid</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">zgrid</span> <span class="o">=</span> <span class="n">zgrid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xgrid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ygrid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ygrid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zgrid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">zgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xgrid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ygrid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ygrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">mesh2grid</span> <span class="o">=</span> <span class="n">int_mat</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">gridinmesh</span> <span class="o">=</span> <span class="n">inside</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># convert to one-based to be compatible with matlab</span>
            
            <span class="c1"># Now calculate the transformation from grid to mesh</span>
            <span class="c1"># We can cheat a little bit because of the regular grid: we can triangularize one voxel and replicate</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zgrid</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ygrid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">nodes0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> 
                                   <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">],</span> 
                                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> 
                                   <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]]])</span>
                <span class="c1"># hard-coded element list</span>
                <span class="n">ele0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="c1"># Calculate integration function within the small cube</span>
                <span class="n">loweridx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">)</span>
                <span class="n">pos_in_cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">-</span> <span class="p">(</span><span class="n">loweridx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
                <span class="n">ind0</span><span class="p">,</span> <span class="n">int_func0</span> <span class="o">=</span> <span class="n">nirfasteruff_cpu</span><span class="o">.</span><span class="n">pointLocation</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">ele0</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">nodes0</span><span class="p">,</span> <span class="n">pos_in_cube</span><span class="p">)</span>
                <span class="c1"># Convert back to the node numbering of the full grid</span>
                <span class="n">raw_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">cube_coord</span> <span class="o">=</span> <span class="n">nodes0</span> <span class="o">+</span> <span class="p">(</span><span class="n">loweridx</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
                    <span class="n">tet_vtx</span> <span class="o">=</span> <span class="n">cube_coord</span><span class="p">[</span><span class="n">ele0</span><span class="p">[</span><span class="n">ind0</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:],</span> <span class="p">:]</span>
                    <span class="n">rel_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">tet_vtx</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span>
                    <span class="n">raw_idx</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">rel_idx</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">xgrid</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">ygrid</span><span class="p">)</span> <span class="o">+</span> <span class="n">rel_idx</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">ygrid</span><span class="p">)</span> <span class="o">+</span> <span class="n">rel_idx</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># zero-based</span>
                
                <span class="n">outvec</span> <span class="o">=</span> <span class="p">(</span><span class="n">loweridx</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">loweridx</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">loweridx</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="o">~</span><span class="n">outvec</span><span class="p">)</span>
                <span class="c1"># if any of the queried nodes was not asigned a value in the previous step,</span>
                <span class="c1"># treat it as an outside node and extrapolate. Otherwise the boundary elements will have smaller values than they should</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">raw_idx</span><span class="p">[</span><span class="n">inside</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">tmp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">gridinmesh</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">outside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">outvec</span><span class="p">),</span> <span class="n">inside</span><span class="p">[</span><span class="n">tmp2</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;</span><span class="n">tmp2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
                <span class="n">inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">inside</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">outside</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ygrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">nodes0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> 
                                   <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
                <span class="c1"># hard-coded element list</span>
                <span class="n">ele0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="c1"># Calculate integration function within the small cube</span>
                <span class="n">loweridx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span><span class="p">)</span>
                <span class="n">pos_in_cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">-</span> <span class="p">(</span><span class="n">loweridx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
                <span class="n">ind0</span><span class="p">,</span> <span class="n">int_func0</span> <span class="o">=</span> <span class="n">nirfasteruff_cpu</span><span class="o">.</span><span class="n">pointLocation</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">ele0</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">nodes0</span><span class="p">,</span> <span class="n">pos_in_cube</span><span class="p">)</span>
                <span class="c1"># Convert back to the node numbering of the full grid</span>
                <span class="n">raw_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">cube_coord</span> <span class="o">=</span> <span class="n">nodes0</span> <span class="o">+</span> <span class="p">(</span><span class="n">loweridx</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
                    <span class="n">tet_vtx</span> <span class="o">=</span> <span class="n">cube_coord</span><span class="p">[</span><span class="n">ele0</span><span class="p">[</span><span class="n">ind0</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:],</span> <span class="p">:]</span>
                    <span class="n">rel_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">tet_vtx</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">res</span>
                    <span class="n">raw_idx</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">rel_idx</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">ygrid</span><span class="p">)</span> <span class="o">+</span> <span class="n">rel_idx</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># zero-based</span>
                
                <span class="n">outvec</span> <span class="o">=</span> <span class="p">(</span><span class="n">loweridx</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">loweridx</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="o">~</span><span class="n">outvec</span><span class="p">)</span>
                <span class="c1"># if any of the queried nodes was not asigned a value in the previous step,</span>
                <span class="c1"># treat it as an outside node and extrapolate. Otherwise the boundary elements will have smaller values than they should</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">raw_idx</span><span class="p">[</span><span class="n">inside</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">tmp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">gridinmesh</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">outside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">outvec</span><span class="p">),</span> <span class="n">inside</span><span class="p">[</span><span class="n">tmp2</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;</span><span class="n">tmp2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
                <span class="n">inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">inside</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">outside</span><span class="p">)))</span>
            
            <span class="n">gridTree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">KDTree</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">gridinmesh</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">_</span><span class="p">,</span><span class="n">nn</span> <span class="o">=</span> <span class="n">gridTree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">outside</span><span class="p">,:])</span>
            <span class="n">int_func_inside</span> <span class="o">=</span> <span class="n">int_func0</span><span class="p">[</span><span class="n">inside</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">raw_idx</span><span class="p">[</span><span class="n">inside</span><span class="p">,:])</span>
            <span class="n">int_mat</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">int_func_inside</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">size</span><span class="p">)],</span> 
                                         <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">inside</span><span class="p">,</span> <span class="n">int_func</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">outside</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">gridinmesh</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">ind0</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">grid2mesh</span> <span class="o">=</span> <span class="n">int_mat</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">meshingrid</span> <span class="o">=</span> <span class="n">inside</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># convert to one-based</span></div>
</div>
</div>


<div class="viewcode-block" id="math">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.math.html#nirfasteruff.nirfasteruff.math">[docs]</a>
<span class="k">class</span> <span class="nc">math</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Dummy class holding some low-level functions. Be careful using them: they interact closely with the C++ functions and wrong arguments used can cause unexpected crashes.</span>
<span class="sd">    Dummy class used so the function hierarchy can be compatible with the full version</span>
<span class="sd">    &#39;&#39;&#39;</span>   
<div class="viewcode-block" id="math.gen_mass_matrix">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.math.html#nirfasteruff.nirfasteruff.math.gen_mass_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">gen_mass_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">solver</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_solver</span><span class="p">(),</span> <span class="n">GPU</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the MASS matrix, and return the coordinates in CSR format.</span>
<span class="sd">        </span>
<span class="sd">        The current Matlab version outputs COO format, so the results are NOT directly compatible</span>
<span class="sd">        </span>
<span class="sd">        If calculation fails on GPU (if chosen), it will generate a warning and automatically switch to CPU</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mesh : nirfasteruff.base.stndmesh</span>
<span class="sd">            the mesh used to calculate the MASS matrix.</span>
<span class="sd">        omega : double</span>
<span class="sd">            modulation frequency, in radian.</span>
<span class="sd">        solver : str, optional</span>
<span class="sd">            Choose between &#39;CPU&#39; or &#39;GPU&#39; solver (case insensitive). Automatically determined (GPU prioritized) if not specified</span>
<span class="sd">        GPU : int, optional</span>
<span class="sd">            GPU selection. -1 for automatic, 0, 1, ... for manual selection on multi-GPU systems. The default is -1.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            if both CUDA and CPU versions fail.</span>
<span class="sd">        TypeError</span>
<span class="sd">            if &#39;solver&#39; is not &#39;CPU&#39; or &#39;GPU&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        csrI: int32 NumPy vector, zero-based</span>
<span class="sd">            I indices of the MASS matrix, in CSR format. Size (NNodes,)</span>
<span class="sd">        csrJ: int32 NumPy vector, zero-based</span>
<span class="sd">            J indices of the MASS matrix, in CSR format. Size (nnz(MASS),)</span>
<span class="sd">        csrV: float64 or complex128 NumPy vector</span>
<span class="sd">            values of the MASS matrix, in CSR format. Size (nnz(MASS),)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">solver</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;gpu&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">isCUDA</span><span class="p">():</span>
            <span class="n">solver</span> <span class="o">=</span> <span class="s1">&#39;CPU&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: No capable CUDA device found. using CPU instead&#39;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">solver</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;gpu&#39;</span> <span class="ow">and</span> <span class="n">utils</span><span class="o">.</span><span class="n">isCUDA</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">[</span><span class="n">csrI</span><span class="p">,</span> <span class="n">csrJ</span><span class="p">,</span> <span class="n">csrV</span><span class="p">]</span> <span class="o">=</span> <span class="n">nirfasteruff_cuda</span><span class="o">.</span><span class="n">gen_mass_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mua</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">kappa</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">ksi</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">GPU</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">omega</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">csrV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">csrV</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: GPU code failed. Rolling back to CPU code&#39;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="p">[</span><span class="n">csrI</span><span class="p">,</span> <span class="n">csrJ</span><span class="p">,</span> <span class="n">csrV</span><span class="p">]</span> <span class="o">=</span> <span class="n">nirfasteruff_cpu</span><span class="o">.</span><span class="n">gen_mass_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mua</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">kappa</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">ksi</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">omega</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">csrV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">csrV</span><span class="p">)</span>    
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Error: couldn&#39;&#39;t generate mass matrix&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">solver</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;cpu&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">[</span><span class="n">csrI</span><span class="p">,</span> <span class="n">csrJ</span><span class="p">,</span> <span class="n">csrV</span><span class="p">]</span> <span class="o">=</span> <span class="n">nirfasteruff_cpu</span><span class="o">.</span><span class="n">gen_mass_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mua</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">kappa</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">ksi</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">omega</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">csrV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">csrV</span><span class="p">)</span> 
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Error: couldn&#39;&#39;t generate mass matrix&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: Solver should be &#39;&#39;GPU&#39;&#39; or &#39;&#39;CPU&#39;&#39;&#39;</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">csrI</span><span class="p">,</span> <span class="n">csrJ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">csrV</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="math.get_field_CW">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.math.html#nirfasteruff.nirfasteruff.math.get_field_CW">[docs]</a>
    <span class="k">def</span> <span class="nf">get_field_CW</span><span class="p">(</span><span class="n">csrI</span><span class="p">,</span> <span class="n">csrJ</span><span class="p">,</span> <span class="n">csrV</span><span class="p">,</span> <span class="n">qvec</span><span class="p">,</span> <span class="n">opt</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">SolverOptions</span><span class="p">(),</span> <span class="n">solver</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">get_solver</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call the Preconditioned Conjugate Gradient solver with FSAI preconditioner. For CW data only.</span>
<span class="sd">        </span>
<span class="sd">        The current Matlab version uses COO format input, so they are NOT directly compatible</span>
<span class="sd">        </span>
<span class="sd">        If calculation fails on GPU (if chosen), it will generate a warning and automatically switch to CPU.</span>
<span class="sd">        </span>
<span class="sd">        On GPU, the algorithm first tries to solve for all sources simultaneously, but this can fail due to insufficient GPU memory.</span>
<span class="sd">        </span>
<span class="sd">        If this is the case, it will generate a warning and solve the sources one by one. The latter is not as fast, but requires much less memory.</span>
<span class="sd">        </span>
<span class="sd">        On CPU, the algorithm only solves the sources one by one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        csrI : int32 NumPy vector, zero-based</span>
<span class="sd">            I indices of the MASS matrix, in CSR format.</span>
<span class="sd">        csrJ : int32 NumPy vector, zero-based</span>
<span class="sd">            J indices of the MASS matrix, in CSR format.</span>
<span class="sd">        csrV : double NumPy vector</span>
<span class="sd">            values of the MASS matrix, in CSR format.</span>
<span class="sd">        qvec : double NumPy array, or Scipy CSC sparse matrix</span>
<span class="sd">            The source vectors. i-th column corresponds to source i. Size (NNode, NSource)</span>
<span class="sd">            </span>
<span class="sd">            See :func:`~nirfasteruff.math.gen_sources()` for details.</span>
<span class="sd">        solver : str, optional</span>
<span class="sd">            Choose between &#39;CPU&#39; or &#39;GPU&#39; solver (case insensitive). Automatically determined (GPU prioritized) if not specified</span>
<span class="sd">        opt : nirfasteruff.utils.SolverOptions, optional</span>
<span class="sd">            Solver options. Uses default parameters if not specified, and they should suffice in most cases. </span>
<span class="sd">            </span>
<span class="sd">            See :func:`~nirfasteruff.utils.SolverOptions` for details</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            if MASS matrix and source vectors are not both real, or if solver is not &#39;CPU&#39; or &#39;GPU&#39;.</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            if both GPU and CPU solvers fail.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        phi: double NumPy array</span>
<span class="sd">            Calculated fluence at each source. Size (NNodes, Nsources)</span>
<span class="sd">        info: nirfasteruff.utils.ConvergenceInfo </span>
<span class="sd">            convergence information of the solver.</span>
<span class="sd">            </span>
<span class="sd">            See :func:`~nirfasteruff.utils.ConvergenceInfo` for details</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        -------</span>
<span class="sd">        :func:`~nirfasteruff.math.gen_mass_matrix()`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">csrV</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">qvec</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;MASS matrix and qvec should be both real&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">solver</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;gpu&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">isCUDA</span><span class="p">():</span>
            <span class="n">solver</span> <span class="o">=</span> <span class="s1">&#39;CPU&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: No capable CUDA device found. using CPU instead&#39;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">solver</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;gpu&#39;</span> <span class="ow">and</span> <span class="n">utils</span><span class="o">.</span><span class="n">isCUDA</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">[</span><span class="n">phi</span><span class="p">,</span> <span class="n">info</span><span class="p">]</span> <span class="o">=</span> <span class="n">nirfasteruff_cuda</span><span class="o">.</span><span class="n">get_field_CW</span><span class="p">(</span><span class="n">csrI</span><span class="p">,</span> <span class="n">csrJ</span><span class="p">,</span> <span class="n">csrV</span><span class="p">,</span> <span class="n">qvec</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">AbsoluteTolerance</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">RelativeTolerance</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">divergence</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">GPU</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: GPU solver failed. Rolling back to CPU solver&#39;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="p">[</span><span class="n">phi</span><span class="p">,</span> <span class="n">info</span><span class="p">]</span> <span class="o">=</span> <span class="n">nirfasteruff_cpu</span><span class="o">.</span><span class="n">get_field_CW</span><span class="p">(</span><span class="n">csrI</span><span class="p">,</span> <span class="n">csrJ</span><span class="p">,</span> <span class="n">csrV</span><span class="p">,</span> <span class="n">qvec</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">AbsoluteTolerance</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">RelativeTolerance</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">divergence</span><span class="p">,</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_nthread</span><span class="p">())</span>  
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Error: solver failed&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">solver</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;cpu&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">[</span><span class="n">phi</span><span class="p">,</span> <span class="n">info</span><span class="p">]</span> <span class="o">=</span> <span class="n">nirfasteruff_cpu</span><span class="o">.</span><span class="n">get_field_CW</span><span class="p">(</span><span class="n">csrI</span><span class="p">,</span> <span class="n">csrJ</span><span class="p">,</span> <span class="n">csrV</span><span class="p">,</span> <span class="n">qvec</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">AbsoluteTolerance</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">RelativeTolerance</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">divergence</span><span class="p">,</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_nthread</span><span class="p">())</span>  
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Error: solver failed&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: Solver should be &#39;&#39;GPU&#39;&#39; or &#39;&#39;CPU&#39;&#39;&#39;</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">phi</span><span class="p">,</span> <span class="n">utils</span><span class="o">.</span><span class="n">ConvergenceInfo</span><span class="p">(</span><span class="n">info</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="math.get_field_FD">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.math.html#nirfasteruff.nirfasteruff.math.get_field_FD">[docs]</a>
    <span class="k">def</span> <span class="nf">get_field_FD</span><span class="p">(</span><span class="n">csrI</span><span class="p">,</span> <span class="n">csrJ</span><span class="p">,</span> <span class="n">csrV</span><span class="p">,</span> <span class="n">qvec</span><span class="p">,</span> <span class="n">opt</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">SolverOptions</span><span class="p">(),</span> <span class="n">solver</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">get_solver</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call the Preconditioned BiConjugate Stablized solver with FSAI preconditioner. </span>
<span class="sd">        </span>
<span class="sd">        This is designed for FD data, but can also work for CW is an all-zero imaginary part is added to the MASS matrix and source vectors.</span>
<span class="sd">        </span>
<span class="sd">        The current Matlab version uses COO format input, so they are NOT directly compatible</span>
<span class="sd">        </span>
<span class="sd">        If calculation fails on GPU (if chosen), it will generate a warning and automatically switch to CPU.</span>
<span class="sd">        </span>
<span class="sd">        On GPU, the algorithm first tries to solve for all sources simultaneously, but this can fail due to insufficient GPU memory.</span>
<span class="sd">        </span>
<span class="sd">        If this is the case, it will generate a warning and solve the sources one by one. The latter is not as fast, but requires much less memory.</span>
<span class="sd">        </span>
<span class="sd">        On CPU, the algorithm only solves the sources one by one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        csrI : int32 NumPy vector, zero-based</span>
<span class="sd">            I indices of the MASS matrix, in CSR format.</span>
<span class="sd">        csrJ : int32 NumPy vector, zero-based</span>
<span class="sd">            J indices of the MASS matrix, in CSR format.</span>
<span class="sd">        csrV : complex double NumPy vector</span>
<span class="sd">            values of the MASS matrix, in CSR format.</span>
<span class="sd">        qvec : complex double NumPy array, or Scipy CSC sparse matrix</span>
<span class="sd">            The source vectors. i-th column corresponds to source i. Size (NNode, NSource)</span>
<span class="sd">            </span>
<span class="sd">            See :func:`~nirfasteruff.math.gen_sources()` for details.</span>
<span class="sd">        solver : str, optional</span>
<span class="sd">            Choose between &#39;CPU&#39; or &#39;GPU&#39; solver (case insensitive). Automatically determined (GPU prioritized) if not specified</span>
<span class="sd">        opt : nirfasteruff.utils.SolverOptions, optional</span>
<span class="sd">            Solver options. Uses default parameters if not specified, and they should suffice in most cases. </span>
<span class="sd">            </span>
<span class="sd">            See :func:`~nirfasteruff.utils.SolverOptions` for details</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            if MASS matrix and source vectors are not both complex, or if solver is not &#39;CPU&#39; or &#39;GPU&#39;.</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            if both GPU and CPU solvers fail.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        phi: complex double NumPy array</span>
<span class="sd">            Calculated fluence at each source. Size (NNodes, Nsources)</span>
<span class="sd">        info: nirfasteruff.utils.ConvergenceInfo </span>
<span class="sd">            convergence information of the solver.</span>
<span class="sd">            </span>
<span class="sd">            See :func:`~nirfasteruff.utils.ConvergenceInfo` for details</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        -------</span>
<span class="sd">        :func:`~nirfasteruff.math.gen_mass_matrix()`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="n">csrV</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">qvec</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;MASS matrix and qvec should be both complex&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">solver</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;gpu&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">isCUDA</span><span class="p">():</span>
            <span class="n">solver</span> <span class="o">=</span> <span class="s1">&#39;CPU&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: No capable CUDA device found. using CPU instead&#39;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">solver</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;gpu&#39;</span> <span class="ow">and</span> <span class="n">utils</span><span class="o">.</span><span class="n">isCUDA</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">[</span><span class="n">phi</span><span class="p">,</span> <span class="n">info</span><span class="p">]</span> <span class="o">=</span> <span class="n">nirfasteruff_cuda</span><span class="o">.</span><span class="n">get_field_FD</span><span class="p">(</span><span class="n">csrI</span><span class="p">,</span> <span class="n">csrJ</span><span class="p">,</span> <span class="n">csrV</span><span class="p">,</span> <span class="n">qvec</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">AbsoluteTolerance</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">RelativeTolerance</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">divergence</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">GPU</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: GPU solver failed. Rolling back to CPU solver&#39;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="p">[</span><span class="n">phi</span><span class="p">,</span> <span class="n">info</span><span class="p">]</span> <span class="o">=</span> <span class="n">nirfasteruff_cpu</span><span class="o">.</span><span class="n">get_field_FD</span><span class="p">(</span><span class="n">csrI</span><span class="p">,</span> <span class="n">csrJ</span><span class="p">,</span> <span class="n">csrV</span><span class="p">,</span> <span class="n">qvec</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">AbsoluteTolerance</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">RelativeTolerance</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">divergence</span><span class="p">,</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_nthread</span><span class="p">())</span>  
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Error: solver failed&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">solver</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;cpu&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">[</span><span class="n">phi</span><span class="p">,</span> <span class="n">info</span><span class="p">]</span> <span class="o">=</span> <span class="n">nirfasteruff_cpu</span><span class="o">.</span><span class="n">get_field_FD</span><span class="p">(</span><span class="n">csrI</span><span class="p">,</span> <span class="n">csrJ</span><span class="p">,</span> <span class="n">csrV</span><span class="p">,</span> <span class="n">qvec</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">AbsoluteTolerance</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">RelativeTolerance</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">divergence</span><span class="p">,</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_nthread</span><span class="p">())</span>  
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Error: solver failed&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: Solver should be &#39;&#39;GPU&#39;&#39; or &#39;&#39;CPU&#39;&#39;&#39;</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">phi</span><span class="p">,</span> <span class="n">utils</span><span class="o">.</span><span class="n">ConvergenceInfo</span><span class="p">(</span><span class="n">info</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="math.gen_sources">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.math.html#nirfasteruff.nirfasteruff.math.gen_sources">[docs]</a>
    <span class="k">def</span> <span class="nf">gen_sources</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the source vectors (point source only) for the sources in mesh.source field</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mesh : NIRFASTer mesh type</span>
<span class="sd">            mesh used to calculate the source vectors. Source information is also defined here.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        qvec : complex double NumPy array</span>
<span class="sd">            source vectors, where each column corresponds to one source. Size (NNodes, Nsources).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">link</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">link</span><span class="p">)</span>
        <span class="n">active</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">link</span><span class="p">[</span><span class="n">link</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">qvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">active</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">int_func</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">int_func</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">pointLocation</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;int function calculated&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">int_func</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># to zero-indexing</span>
            <span class="n">int_func</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">int_func</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
        
        <span class="n">dim</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">dimension</span>
        <span class="n">qvec</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">((</span><span class="n">int_func</span><span class="p">[</span><span class="n">active</span><span class="p">,:]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">ind</span><span class="p">,:]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">active</span><span class="o">.</span><span class="n">size</span><span class="p">),</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">))),</span>
                                 <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">active</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">qvec</span></div>

    
<div class="viewcode-block" id="math.get_boundary_data">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.math.html#nirfasteruff.nirfasteruff.math.get_boundary_data">[docs]</a>
    <span class="k">def</span> <span class="nf">get_boundary_data</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates boundary data given the field data in mesh</span>
<span class="sd">        </span>
<span class="sd">        The field data can be any of the supported type: fluence, TPSF, or moments</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mesh : nirfasteruff mesh type</span>
<span class="sd">            the mesh whose boundary and detectors are used for the calculation.</span>
<span class="sd">        phi : double or complex double NumPy array</span>
<span class="sd">            field data as calculated by one of the &#39;get_field_*&#39; solvers. Size (NNodes, NSources)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : double or complex double NumPy array</span>
<span class="sd">            measured boundary data at each channel. Size (NChannels,).</span>

<span class="sd">        &quot;&quot;&quot;</span>
       
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">int_func</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calculating missing detectors integration functions.&#39;</span><span class="p">)</span>
            <span class="n">ind</span><span class="p">,</span> <span class="n">int_func</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">pointLocation</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">int_func</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">int_func</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">int_func</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span>
        
        <span class="n">link</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">link</span><span class="p">)</span>
        <span class="n">link</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c1"># to zero-indexing</span>
        <span class="n">active_src</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">link</span><span class="p">[</span><span class="n">link</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">bnd</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bndvtx</span><span class="o">&gt;</span><span class="mi">0</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">link</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">phi</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">link</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">link</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">continue</span>
            <span class="n">tri</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">link</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">int_func_tmp</span> <span class="o">=</span> <span class="n">int_func</span><span class="p">[</span><span class="n">link</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],:]</span> <span class="o">*</span> <span class="n">bnd</span><span class="p">[</span><span class="n">tri</span><span class="p">]</span>
            <span class="n">int_func_tmp</span> <span class="o">/=</span> <span class="n">int_func_tmp</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">int_func_tmp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">tri</span><span class="p">,</span> <span class="n">active_src</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">link</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">])])</span>
        
        <span class="k">return</span> <span class="n">data</span></div>
</div>

            

<div class="viewcode-block" id="forward">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.forward.html#nirfasteruff.nirfasteruff.forward">[docs]</a>
<span class="k">class</span> <span class="nc">forward</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Dummy class holding the forward modeling functions.</span>
<span class="sd">    Dummy class used so the function hierarchy can be compatible with the full version</span>
<span class="sd">    &#39;&#39;&#39;</span> 
<div class="viewcode-block" id="forward.femdata_stnd_CW">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.forward.html#nirfasteruff.nirfasteruff.forward.femdata_stnd_CW">[docs]</a>
    <span class="k">def</span> <span class="nf">femdata_stnd_CW</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">solver</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_solver</span><span class="p">(),</span> <span class="n">opt</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">SolverOptions</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward modeling for CW. Please consider using mesh.femdata(0) instead.</span>
<span class="sd">        </span>
<span class="sd">        The function calculates the FEM MASS matrix, the source vectors, and calls the CW solver (preconditioned conjugated gradient).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mesh : nirfasteruff.base.stndmesh</span>
<span class="sd">            the mesh used to calcuate the forward data.</span>
<span class="sd">        solver : str, optional</span>
<span class="sd">            Choose between &#39;CPU&#39; or &#39;GPU&#39; solver (case insensitive). Automatically determined (GPU prioritized) if not specified</span>
<span class="sd">        opt : nirfasteruff.utils.SolverOptions, optional</span>
<span class="sd">            Solver options. Uses default parameters if not specified, and they should suffice in most cases. </span>
<span class="sd">            </span>
<span class="sd">            See :func:`~nirfasteruff.utils.SolverOptions` for details</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If mesh is not a stnd mesh.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : nirfasteruff.base.FDdata</span>
<span class="sd">            fluence and boundary measurables given the mesh and optodes.</span>
<span class="sd">            </span>
<span class="sd">            If mesh.vol is defined, the returned fluence will be in volumetric space</span>
<span class="sd">            </span>
<span class="sd">            See :func:`~nirfasteruff.base.FDdata` for details.</span>
<span class="sd">        info : nirfasteruff.utils.ConvergenceInfo</span>
<span class="sd">            convergence information of the solver.</span>
<span class="sd">            </span>
<span class="sd">            See :func:`~nirfasteruff.utils.ConvergenceInfo` for details</span>
<span class="sd">            </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`~nirfasteruff.math.get_field_CW()`, :func:`~nirfasteruff.math.gen_mass_matrix()`, and :func:`~nirfasteruff.math.gen_sources()`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># print(&quot;Calculating the MASS matrix&quot;, flush=1)</span>
        <span class="n">csrI</span><span class="p">,</span> <span class="n">csrJ</span><span class="p">,</span> <span class="n">csrV</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">gen_mass_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">solver</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">GPU</span><span class="p">)</span>
        <span class="n">qvec</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">gen_sources</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        <span class="n">qvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qvec</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">FDdata</span><span class="p">()</span>
        <span class="c1"># print(&quot;Solving the system&quot;, flush=1)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">get_field_CW</span><span class="p">(</span><span class="n">csrI</span><span class="p">,</span> <span class="n">csrJ</span><span class="p">,</span> <span class="n">csrV</span><span class="p">,</span> <span class="n">qvec</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">solver</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">complex</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">get_boundary_data</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">link</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">complex</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">phase</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">complex</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">data</span><span class="o">.</span><span class="n">vol</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">xgrid</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">zgrid</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">mesh2grid</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">phi</span><span class="p">),</span> <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">ygrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">xgrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">zgrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">qvec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">mesh2grid</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">phi</span><span class="p">),</span> <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">ygrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">xgrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">qvec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="n">tmp</span>
        
        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">info</span></div>

    
<div class="viewcode-block" id="forward.femdata_stnd_FD">
<a class="viewcode-back" href="../../_autosummary/nirfasteruff.nirfasteruff.forward.html#nirfasteruff.nirfasteruff.forward.femdata_stnd_FD">[docs]</a>
    <span class="k">def</span> <span class="nf">femdata_stnd_FD</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">solver</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_solver</span><span class="p">(),</span> <span class="n">opt</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">SolverOptions</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward modeling for FD. Please consider using mesh.femdata(freq) instead. freq in Hz</span>
<span class="sd">        </span>
<span class="sd">        The function calculates the MASS matrix, the source vectors, and calls the FD solver (preconditioned BiCGStab).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mesh : nirfasteruff.base.stndmesh</span>
<span class="sd">            the mesh used to calcuate the forward data.</span>
<span class="sd">        freq : double</span>
<span class="sd">            modulation frequency in Hz. </span>
<span class="sd">            </span>
<span class="sd">            When it is 0, function continues with the BiCGstab solver, but generates a warning that the CW solver should be used for better performance</span>
<span class="sd">        solver : str, optional</span>
<span class="sd">            Choose between &#39;CPU&#39; or &#39;GPU&#39; solver (case insensitive). Automatically determined (GPU prioritized) if not specified</span>
<span class="sd">        opt : nirfasteruff.utils.SolverOptions, optional</span>
<span class="sd">            Solver options. Uses default parameters if not specified, and they should suffice in most cases. </span>
<span class="sd">            </span>
<span class="sd">            See :func:`~nirfasteruff.utils.SolverOptions` for details</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If mesh is not a stnd mesh.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : nirfasteruff.base.FDdata</span>
<span class="sd">            fluence and boundary measurables given the mesh and optodes.</span>
<span class="sd">            </span>
<span class="sd">            If mesh.vol is defined, the returned fluence will be in volumetric space</span>
<span class="sd">            </span>
<span class="sd">            See :func:`~nirfasteruff.base.FDdata` for details.</span>
<span class="sd">        info : nirfasteruff.utils.ConvergenceInfo</span>
<span class="sd">            convergence information of the solver.</span>
<span class="sd">            </span>
<span class="sd">            See :func:`~nirfasteruff.utils.ConvergenceInfo` for details</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`~nirfasteruff.math.get_field_FD()`, :func:`~nirfasteruff.math.gen_mass_matrix()`, and :func:`~nirfasteruff.math.gen_sources()`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">freq</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Use femdata_stnd_CW for better performance&#39;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="c1"># print(&quot;Calculating the MASS matrix&quot;, flush=1)</span>
        <span class="n">csrI</span><span class="p">,</span> <span class="n">csrJ</span><span class="p">,</span> <span class="n">csrV</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">gen_mass_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">solver</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">GPU</span><span class="p">)</span>
        <span class="n">qvec</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">gen_sources</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">FDdata</span><span class="p">()</span>
        <span class="c1"># print(&quot;Solving the system&quot;, flush=1)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">get_field_FD</span><span class="p">(</span><span class="n">csrI</span><span class="p">,</span> <span class="n">csrJ</span><span class="p">,</span> <span class="n">csrV</span><span class="p">,</span> <span class="n">qvec</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">solver</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">complex</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">get_boundary_data</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">link</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span><span class="o">*</span><span class="mf">180.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">data</span><span class="o">.</span><span class="n">vol</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">xgrid</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">zgrid</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">mesh2grid</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">phi</span><span class="p">),</span> <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">ygrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">xgrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">zgrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">qvec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">mesh2grid</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">phi</span><span class="p">),</span> <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">ygrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">xgrid</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">qvec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="n">tmp</span>
        
        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">info</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Jiaming Cao, MILAB@UoB.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>